{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Sitio web con los apuntes de la asignatura \"Servicios de las Plataformas M\u00f3viles (iOS)\" del Master en Desarrollo de Software para Dispositivos M\u00f3viles.</p> <p>Despliega el men\u00fa de la izquierda para consultar los apuntes.</p>"},{"location":"practicas/anuncios/anuncios.html","title":"Pr\u00e1ctica 5: Anuncios (Opcional)","text":"<p>Esta pr\u00e1ctica es opcional.</p> <p>En la pr\u00e1ctica deber\u00e1s a\u00f1adir anuncios a la app <code>ToDo</code>.</p> <ul> <li>Debes a\u00f1adir un banner en la parte inferior de la lista de tareas. </li> <li>El anuncio del banner debe cambiar cada vez que se vuelve a esta   lista desde la pantalla con el resumen de tareas completadas.</li> <li>Una de cada cinco veces que se vuelva a esta lista de tareas debe   mostrarse un anuncio intersticial.</li> <li>En la pantalla del resumen de tareas completadas debes poner un   bot\u00f3n que abra una alerta para quitar los anuncios. Una vez que el   usuario lo confirme dejar\u00e1n de mostrarse anuncios en la app.</li> </ul>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html","title":"Pr\u00e1ctica 1: Firma, aprovisionamiento y  distribuci\u00f3n de apps","text":"<p>En las pr\u00e1cticas de esta sesi\u00f3n deber\u00e1s trabajar con distintos aspectos relacionados con la firma, la distribuci\u00f3n y el despliegue de apps en dispositivos reales.</p> <p>Resumimos a continuaci\u00f3n los objetivos generales de esta pr\u00e1ctica:</p> <ol> <li>Firmar una app con tu cuenta gratuita e instalarla en un    dispositivo configurado como dispositivo de desarrollo.</li> <li>Importar un certificado de desarrollo de Apple.</li> <li>Firmar y exportar la app usando un perfil de aprovisionamiento que    te permite instalarla en cualquier dispositivo autorizado en el    perfil.</li> <li>Configurar en la aplicaci\u00f3n una capacidad y seleccionar un perfil    del equipo de desarrollo que permita esta capacidad.</li> </ol>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#1-antes-de-empezar-la-clase-presencial","title":"1. Antes de empezar la clase presencial","text":"<ol> <li> <p>Antes de la clase presencial deber\u00e1s mirar los tres v\u00eddeos con demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n 1.</p> </li> <li> <p>Una vez vistas estas demostraciones, debes leer los    siguientes apartados del tema de teor\u00eda:</p> <ul> <li>Introducci\u00f3n:  Resumen de lo que vamos a ver en este tema e introducci\u00f3n breve a  la importancia de la seguridad en la plataforma de Apple.</li> <li>Cuenta de desarrollador de Apple:  Explicaci\u00f3n de los distintos tipo de programas de desarrollo en  la plataforma Apple y caracter\u00edsticas de cada uno.</li> <li>Certificado de firma de   apps: Explicaci\u00f3n del funcionamiento del certificado de desarrollador   para la firma de apps. Una app s\u00f3lo puede instalarse en un   dispositivo si ha sido previamente firmada con un certificado de   un desarrollador registrado.</li> <li>Capacidades de las   aps:   Para usar las capacidades proporcionadas por la plataforma de   desarrollo Apple es necesario configurar una autorizaci\u00f3n usando   un App ID.</li> <li>Despliegue de   apps:   para desplegar una app en un dispositivo de prueba es necesario instalar en ella un perfil de   aprovisionamiento que contenga los permisos para acceder a las   capacidades y los dispositivos autorizados en los que la app   puede instalarse.</li> </ul> </li> </ol>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#2-firma-e-instalacion-de-una-app-en-un-dispositivo-de-desarrollo","title":"2. Firma e instalaci\u00f3n de una app en un dispositivo de desarrollo","text":"<ol> <li> <p>Deber\u00e1s crear un Apple ID y darte de alta como desarrollador. Si ya lo tienes, no hace falta que hagas nada.</p> <p>Para crear un Apple ID, puedes introducir tus datos en este enlace. Este Apple ID ser\u00e1 el que se asociar\u00e1 a la cuenta de desarrollador.</p> <p>Despu\u00e9s deber\u00e1s darte de alta como desarrollador Apple con el Apple ID reci\u00e9n creado en https://developer.apple.com.</p> </li> <li> <p>Accede a tu portal de desarrollador. Ser\u00e1 el portal del programa    gratuito. Este programa permite acceder a las herramientas de    desarrollo, la documentaci\u00f3n y acceso limitado a ciertas    capacidades (incluido probar aplicaciones en dispositivos    conectados a Xcode).</p> <p>Explora las distintas opciones que permite la cuenta:</p> <ul> <li>Documentation</li> <li>Downloads</li> <li>Forums</li> <li>Bug reporter</li> <li>Help</li> </ul> </li> <li> <p>Descarga la app    ToDo (versi\u00f3n storyboards) o ToDo (versi\u00f3n SwiftUI). Y    sigue los pasos de la demostraci\u00f3n para crear el certificado    gratuito de desarrollador, cambiar el bundle ID de la app a un    identificador tuyo, firmar la app, comprobar el certificado y    probar la app en tu dispositivo de desarrollo (si lo tienes).</p> </li> <li> <p>Incluye tu nombre en la pantalla en la que aparece el n\u00famero de    tareas terminadas (a la que se accede pulsando en el bot\u00f3n Done).</p> </li> <li> <p>Captura la pantalla de Xcode en la que se muestra el bundle ID y el    equipo que realiza la firma. Captura tambi\u00e9n una instant\u00e1nea con la    app ejecut\u00e1ndose en el dispositivo mostrando la pantalla con tu    nombre. Si no tienes dispositivo, hazlo con la ejecuci\u00f3n del    simulador. </p> </li> <li> <p>Comprueba que aparece un error cuando intentas exportar la    app. Captura la pantalla de Xcode.</p> </li> </ol>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#3-importar-un-certificado-de-desarrollador","title":"3. Importar un certificado de desarrollador","text":"<ol> <li> <p>Para poder firmar las aplicaciones necesitamos un certificado de desarrollador. Puedes descargar el certificado desde la p\u00e1gina Moodle de la asignatura (se trata de un fichero con extensi\u00f3n <code>.p12</code>).</p> </li> <li> <p>Importar el certificado, haciendo doble click sobre el fichero. Nos pedir\u00e1 una contrase\u00f1a que se proporcionar\u00e1 en clase.</p> </li> <li> <p>Tras introducir la contrase\u00f1a, el certificado habr\u00e1 quedado instalado en el sistema. Podemos comprobarlo, por ejemplo, mediante la aplicaci\u00f3n Acceso a llaveros, donde deberemos encontrar un item llamado \"Apple Development: Miguel Angel Lozano Ortega\". Tendremos tanto el certificado como la clave privada asociada, necesaria para la firma. </p> </li> <li> <p>Para poder probar las aplicaciones en dispositivos f\u00edsicos, es necesario darlos de alta en la cuenta de Apple y actualizar los perfiles de aprovisionamiento para incluirlos. Para realizar esto, incluye en este fichero Google Docs el ID del dispositivo (o dispositivos que desees incorporar.</p> </li> </ol>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#4-firma-y-despliegue-de-app-con-perfil-de-aprovisionamiento","title":"4. Firma y despliegue de app con perfil de aprovisionamiento","text":"<p>Sigue los pasos de la demo y    ejercicio    de teor\u00eda, realizando lo siguiente:</p> <p>Importante: No ser\u00e1 necesario realizar ninguna acci\u00f3n en developer portal, ya que ya hemos  importado un certificado de desarrollo y los perfiles de aprovisionamiento necesarios est\u00e1n creados. </p> <ol> <li> <p>Cambia el bundle ID y firma la app con el perfil Gen\u00e9rico. Captura la pantalla de Xcode en la que se muestre esto. </p> </li> <li> <p>Comprueba que es posible exportar la app utilizando el perfil     Gen\u00e9rico. Captura la pantalla.</p> </li> <li> <p>Comprueba que aparece un error cuando intentas a\u00f1adir la capacidad    <code>Game Center</code> usando el perfil Gen\u00e9rico. Captura la pantalla.</p> </li> <li> <p>Cambia al perfil <code>Master Moviles ToDo</code> y a\u00f1ade la    capacidad <code>Game Center</code> (que si que se encuentra activada en este perfil). Comprueba que Xcode no da ning\u00fan error y    captura la pantalla.</p> </li> <li> <p>Exporta la app, creando un binario .ipa. Si tienes alg\u00fan    dispositivo iOS, instala el fichero .ipa obtenido usando Apple    Configurator.. El UUID del dispositivo deber\u00e1 estar incluido en el    perfil de aprovisionamiento. Captura una pantalla de la aplicaci\u00f3n    <code>Apple Configurator</code> instalando la app en el    dispositivo. Comprueba que la app funciona correctamente.</p> </li> </ol>"},{"location":"practicas/aprovisionamiento/firma-aprovisionamiento.html#5-entrega","title":"5. Entrega","text":"<p>Crea una carpeta y guarda en ella lo siguiente:</p> <ul> <li>Todas las capturas de pantalla (un total de 8 im\u00e1genes).</li> <li>Binario .ipa exportado en el \u00faltimo paso.</li> <li>Carpeta con el proyecto completo.</li> </ul> <p>Comprime la carpeta y entr\u00e9gala en la actividad de Moodle Entrega 1.</p>"},{"location":"practicas/extesiones/extensiones.html","title":"Pr\u00e1ctica 5: Extensiones","text":"<ul> <li>Implementar una extensi\u00f3n Today en la app ToDoList. </li> <li>En la pantalla principal de la extensi\u00f3n debe aparecer el n\u00famero de   \u00edtems completados y nombre del \u00faltimo de ellos.</li> <li>Para comunicar los datos entre la app y la extensi\u00f3n debes usar el   <code>UserDefaults</code> compartido en el grupo de apps.</li> <li>Puedes consultar los nombres del grupo de apps y de los bundle   identifiers asociados a los App Ids en el member center de la UA.</li> </ul> <p>Parte opcional</p> <ul> <li>Implementa una vista ampliada de la extensi\u00f3n que permita al usuario   ver m\u00e1s datos de la lista de tareas por hacer.</li> </ul>"},{"location":"practicas/icloud/icloud.html","title":"Pr\u00e1ctica 4: iCloud y CloudKit","text":"<p>Seguimos trabajando con el proyecto <code>ToDo</code> y el bundle ID <code>es.ua.mudsdm.ToDo</code> y el perfil de aprovisionamiento <code>Master Moviles ToDo</code> (est\u00e1 actualizado e incluye el permiso de acceso a CloudKit y al contenedor <code>iCloud.es.ua.mudsdm.ToDo</code>).</p> <p>Puedes optar por hacer el ejercicio sobre la versi\u00f3n de ToDo basada en storyboards o la basada en SwiftUI. En caso de elegir esta segunda opci\u00f3n, se recomienda leer la secci\u00f3n de teor\u00eda sobre SwiftUI como ayuda.</p>"},{"location":"practicas/icloud/icloud.html#1-antes-de-empezar-la-clase-presencial","title":"1. Antes de empezar la clase presencial","text":"<ol> <li> <p>Antes de la clase presencial deber\u00e1s mirar los dos v\u00eddeos con    demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n 4. Son    muy \u00fatiles para entender los conceptos que se explican en m\u00e1s    profundidad en teor\u00eda y para explicar las pr\u00e1cticas que hay que    hacer en este tema.</p> </li> <li> <p>Lee los apartados de teor\u00eda para entender el funcionamiento de    iCloud clave-valor y los aspectos b\u00e1sicos de CloudKit.</p> </li> </ol>"},{"location":"practicas/icloud/icloud.html#2-parte-obligatoria-hasta-7-puntos","title":"2. Parte obligatoria (hasta 7 puntos)","text":"<ul> <li>Actualiza en Xcode el permiso para utilizar iCloud, con clave-valor   y con CloudKit.</li> <li>Modifica la app ToDo para que el n\u00famero de \u00edtems terminados se   guarde en iCloud del usuario, usando iCloud clave-valor.</li> </ul> <ul> <li> <p>A\u00f1ade el c\u00f3digo necesario para que las tareas pendientes   se guarden y recuperen de la base de datos privada de   CloudKit. </p> <p>En el contenedor de CloudKit se ha a\u00f1adido el tipo de registro <code>Tarea</code> con el campo <code>nombre</code> con los \u00edndices <code>Queryable</code>, <code>Searchable</code>, <code>Sortable</code>. </p> </li> </ul>"},{"location":"practicas/icloud/icloud.html#pista-para-actualizar-la-tabla","title":"Pista para actualizar la tabla","text":"<ul> <li>Los callbacks en los que se reciben los resultados de las   queries son as\u00edncronos y se procesan en hilos secundarios.</li> <li>Si actualizamos los datos de la tabla en un callback de este tipo,   la interfaz de usuario no se refrescar\u00e1 hasta que el usuario no   interact\u00fae con la tabla.</li> <li>Se puede forzar a ejecutar la actualizaci\u00f3n de los datos de la tabla en   el hijo principal con este c\u00f3digo en alg\u00fan lugar del <code>ToDoTableViewController</code>:</li> </ul> <pre><code>DispatchQueue.main.async( execute: {\n    self.tableView.reloadData()\n})\n</code></pre>"},{"location":"practicas/icloud/icloud.html#3-parte-opcional-3-puntos","title":"3.  Parte opcional (3 puntos)","text":"<ul> <li> <p>Utiliza la base de datos p\u00fablica de CloudKit para publicar tareas compartidas   por todos los usuarios de la app. Al a\u00f1adir una tarea debes permitir   la opci\u00f3n de hacerlo en la base de datos p\u00fablica. Muestra el texto   de las tareas p\u00fablicas en un color diferente en el listado de   tareas.</p> </li> <li> <p>A\u00f1ade una funcionalidad en la que se recargue la   tabla con los datos de iCloud cuando se tire de la tabla hacia   abajo. </p> </li> </ul>"},{"location":"practicas/icloud/icloud.html#4-entrega","title":"4. Entrega","text":"<p>Entrega una carpeta comprimida con el proyecto y un peque\u00f1o documento PDF en el que expliques las funcionalidades implementadas. </p> <p>Si el tama\u00f1o de la entrega supera los 20MB, sube la entrega a Google Drive o similar e incluye un enlace.</p>"},{"location":"practicas/mapas/mapas-localizacion.html","title":"Pr\u00e1ctica 2","text":""},{"location":"practicas/mapas/mapas-localizacion.html#practica-2-mapas-y-localizacion","title":"Pr\u00e1ctica 2: Mapas y localizaci\u00f3n","text":""},{"location":"practicas/mapas/mapas-localizacion.html#1-antes-de-empezar-la-clase-presencial","title":"1. Antes de empezar la clase presencial","text":"<ol> <li> <p>Antes de la clase presencial deber\u00e1s mirar los tres v\u00eddeos con demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n 2.</p> </li> <li> <p>Una vez vistas estas demostraciones, debes leer los siguientes apartados del tema de teor\u00eda:</p> <ul> <li> <p>Aspectos b\u00e1sicos de   MapKit:   desde Aspectos b\u00e1sicos de MapKit hasta Uso del delegado   (incluido). Explicaci\u00f3n de la creaci\u00f3n de mapas en una app y del   uso del delegado para procesar las acciones del usuario sobre el   mapa. </p> </li> <li> <p>Anotaciones:   desde Anotaciones hasta Elementos en el callout   (incluido). Explicaci\u00f3n de la creaci\u00f3n y uso de   anotaciones. Con estos apartados y los anteriores puedes hacer   la parte obligatoria de la pr\u00e1ctica.</p> </li> </ul> </li> </ol>"},{"location":"practicas/mapas/mapas-localizacion.html#2-parte-obligatoria-hasta-7-puntos","title":"2. Parte obligatoria (hasta 7 puntos)","text":"<ol> <li> <p>Debes crear la app <code>es.ua.mastermoviles.Mapas</code>.</p> </li> <li> <p>Empieza por definir un View Controller en el que debes incluir un mapa centrado inicialmente en Alicante. Incl\u00fayelo en un Navigation Controller con la opci\u00f3n Editor &gt; Embed In &gt; Navigation Controller.</p> </li> <li> <p>A\u00f1ade en el centro de la barra del Navigation Controller un Segmented Control con los valores <code>Mapa</code> y <code>Sat\u00e9lite</code>, con\u00e9ctalos con el ViewController y haz que el mapa cambie de tipo cuando se pulse en el control.</p> </li> </ol> <p> </p> <ol> <li> <p>En el Storyboard a\u00f1ade un <code>Bar Button Item</code> en la parte derecha de la barra de navegaci\u00f3n.</p> </li> <li> <p>Ll\u00e1malo <code>Pin</code> y enl\u00e1zalo con una acci\u00f3n en el <code>ViewController</code> que   a\u00f1ada una anotaci\u00f3n en el mapa.</p> </li> </ol> <p> </p> <ol> <li> <p>A\u00f1ade en los callouts im\u00e1genes thumbnails predefinidas, dependiendo de si el n\u00famero de pin es par o impar.</p> </li> <li> <p>A\u00f1ade en los callouts el bot\u00f3n de informaci\u00f3n.</p> </li> </ol> <p> </p>"},{"location":"practicas/mapas/mapas-localizacion.html#3-parte-opcional-3-puntos","title":"3. Parte opcional (3 puntos)","text":"<p>Debes leer los siguientes apartados del tema de teor\u00eda:</p> <ul> <li> <p>Geocoding:       desde Geocoding hasta Conversi\u00f3n de placemarks en       localizaciones (incluido). Explicaci\u00f3n de la t\u00e9cnica de       geocoding (obtenci\u00f3n del nombre a partir de las coordenadas       geogr\u00e1ficas). Este apartado se usan para la primera parte       opcional de la pr\u00e1ctica.</p> </li> <li> <p>Localizaci\u00f3n:       explicaci\u00f3n de c\u00f3mo activar y acceder a los servicios de       localizaci\u00f3n. Necesario para la tercera parte opcional de la pr\u00e1ctica.</p> </li> </ul> <p>Parte opcional 1</p> <ol> <li>Implementa un segue que haga aparecer otra vista con un detalle   de la foto. Puedes definir un segue haciendo control click desde un  view controller hasta otro. Despu\u00e9s debes dar un identificador al   segue. Por ejemplo <code>DetalleImagen</code>.</li> </ol> <p> </p> <p>Parte opcional 2</p> <ol> <li>Implementa una llamada al servicio de geolocalizaci\u00f3n que coloque    como subt\u00edtulo del Pin el pa\u00eds en el que se ha colocado el    mismo. </li> </ol> <p> </p> <p>Parte opcional 3</p> <ol> <li> <p>A\u00f1ade el tracking de localizaci\u00f3n a la aplicaci\u00f3n, imprimiendo la localizaci\u00f3n en la salida est\u00e1ndar cada 10 metros. Comprueba el funcionamiento activando la localizaci\u00f3n en el simulador.</p> </li> <li> <p>A\u00f1ade la localizaci\u00f3n al mapa, haciendo que aparezca en la parte izquierda de la barra de navegaci\u00f3n el bot\u00f3n de navegaci\u00f3n.</p> <ul> <li> <p>Cuando pulses el bot\u00f3n de navegaci\u00f3n se debe mostrar la posici\u00f3n   actual del dispositivo.</p> </li> <li> <p>Deber\u00e1s modificar la funci\u00f3n que muestra la vista de una   anotaci\u00f3n   (<code>mapView(_:viewFor:)</code>)   porque se utiliza tambi\u00e9n para mostrar la vista de la posici\u00f3n   actual del dispositivo (que tambi\u00e9n es una anotaci\u00f3n). Si la   anotaci\u00f3n que se quiere mostrar no es de tipo Pin debes poner la   vista a <code>nil</code> para que se use la vista por defecto (el c\u00edrculo).</p> </li> </ul> </li> </ol> <p> </p>"},{"location":"practicas/mapas/mapas-localizacion.html#4-entrega","title":"4. Entrega","text":"<p>Entrega una carpeta comprimida con el proyecto y un peque\u00f1o documento PDF en el que expliques las funcionalidades implementadas. </p> <p>Si el tama\u00f1o de la entrega supera los 20MB, sube la entrega a Google Drive o similar e incluye un enlace.</p>"},{"location":"practicas/notificaciones/notificaciones.html","title":"Pr\u00e1ctica 3: Notificaciones","text":""},{"location":"practicas/notificaciones/notificaciones.html#1-antes-de-empezar-la-clase-presencial","title":"1. Antes de empezar la clase presencial","text":"<ol> <li> <p>Antes de la clase presencial deber\u00e1s mirar los tres v\u00eddeos con    demostraciones que podr\u00e1s encontrar en Moodle, en la sesi\u00f3n de Notificaciones. En caso de optar por realizar los ejercicios en su versi\u00f3n de SwiftUI, se recomienda tambi\u00e9n ver el v\u00eddeo sobre la aplicaci\u00f3n ToDo con SwiftUI.</p> </li> <li> <p>Una vez vistas estas demostraciones, debes leer los siguientes apartados del tema de teor\u00eda:</p> <ul> <li> <p>Introducci\u00f3n:   Conceptos b\u00e1sicos de notificaciones en iOS. Notificaciones   locales y remotas. NotificationCenter.</p> </li> <li> <p>Preparaci\u00f3n de las notificaciones:   Petici\u00f3n de permiso a los usuarios.</p> </li> <li> <p>Notificaciones   locales y Demo:   Creaci\u00f3n de notificaciones. Demo con el app Notificaciones.</p> </li> <li> <p>Acciones, Manejo de notificaciones y   Demo:   Acciones en las notificaciones. Manejadores de las notificaciones.</p> </li> </ul> </li> </ol>"},{"location":"practicas/notificaciones/notificaciones.html#2-parte-obligatoria-hasta-7-puntos","title":"2. Parte obligatoria (hasta 7 puntos)","text":"<p>Descarga las apps Notificaciones y NotificacionesPush,    revisa su c\u00f3digo y sus permisos y pru\u00e9balas. La primera puedes probarla en el    simulador. La segunda deber\u00e1s probarla ejecut\u00e1ndola en un    dispositivo real y enviando notificaciones remotas tal y como hemos    hecho en la demo.</p> <ul> <li>Modifica la app ToDo para que genere notificaciones locales. En   la app ToDo puedes hacerlo con un bot\u00f3n en la pantalla con el   n\u00famero de tareas terminadas. Deber\u00e1s generar una notificaci\u00f3n en el   intervalo de 10 segundos que contenga alguna imagen y acciones. Y   visualizar la acci\u00f3n que el usuario ha realizado sobre la   notificaci\u00f3n, lanzando una   alerta   la siguiente vez que se abra la app que informe de la acci\u00f3n   escogida.</li> </ul> <p>Puedes optar por hacer el ejercicio sobre la versi\u00f3n de ToDo basada en storyboards o la basada en SwiftUI. En caso de elegir esta segunda opci\u00f3n, se recomienda leer la secci\u00f3n de teor\u00eda sobre SwiftUI como ayuda.</p>"},{"location":"practicas/notificaciones/notificaciones.html#3-parte-opcional-3-puntos","title":"3. Parte opcional (3 puntos)","text":"<p>Lee los siguientes apartados del tema de teor\u00eda:</p> <ul> <li> <p>Notificaciones   remotas:   Arquitectura de las notificaciones remotas. Registro del   dispositivo. Payload de la notificaci\u00f3n.</p> </li> <li> <p>Ejercicio para los que no tienen dispositivo f\u00edsico iOS: Implementa una notificaci\u00f3n basada en el   calendario, en la que dejes al usuario seleccionar la   hora y minuto en la que aparezca una notificaci\u00f3n informando del   n\u00famero de tareas terminadas.</p> </li> <li> <p>Ejercicio para los que tienen dispositivo f\u00edsico iOS: A\u00f1ade la   posiblidad de a\u00f1adir una nueva tarea en la lista de tareas   pendientes mediante una notificaci\u00f3n silenciosa enviada con una   notificaci\u00f3n push. Sigue primero el   ejercicio   del tema para probar la aplicaci\u00f3n NotificacionesPush y el env\u00edo de   notificaciones desde el terminal con un JWS. Deber\u00e1s utilizar un   dispositivo real para realizar las pruebas.</p> </li> </ul>"},{"location":"practicas/notificaciones/notificaciones.html#4-entrega","title":"4. Entrega","text":"<p>Firma la app resultante, exporta el fichero IPA y entr\u00e9galo en Moodle, junto con el proyecto comprimido y un documento PDF con una breve descripci\u00f3n de las funcionalidades a\u00f1adidas.</p>"},{"location":"teoria/anuncios/anuncios.html","title":"Anuncios y compras In-App","text":""},{"location":"teoria/anuncios/anuncios.html#anuncios","title":"Anuncios","text":""},{"location":"teoria/anuncios/anuncios.html#redes-de-anuncios","title":"Redes de anuncios","text":"<p> x </p> <p>Hasta 2016 Apple hab\u00eda explotado iAD, una red de anuncios propia, con su propia API, orientada espec\u00edficamente a apps iOS. Durante varios a\u00f1os hab\u00eda intentado competir con las redes m\u00e1s populares como AdMob (Google). Al final no consigui\u00f3 destacar y la red se cerr\u00f3 en junio de 2016.</p> <p>Desde entonces los desarrolladores iOS tienen que escoger entre distintas redes existentes:</p> <ul> <li>AdMob (Google)</li> <li>Unity Ads </li> <li>Facebook Ads </li> <li>Amazon Ads</li> </ul> <p>Cada red tiene su propia API, aunque son todas ellas muy similares.</p>"},{"location":"teoria/anuncios/anuncios.html#api-de-admob","title":"API de AdMob","text":"<p>Vamos a ver la red AdMob de Google, por ser la m\u00e1s popular. Vamos a explicar AdMob sin Firebase, para hacer m\u00e1s ligera la app y tener que depender del n\u00famero m\u00ednimo de librer\u00edas.</p> <p> </p>"},{"location":"teoria/anuncios/anuncios.html#alta-en-admob","title":"Alta en AdMob","text":"<p>Lo primero que tenemos que hacer para probar los anuncios y el API de AdMob es crear una cuenta de AdMob y registrar una aplicaci\u00f3n.</p> <p>Una vez dado de alta y creada la aplicaci\u00f3n, tendr\u00e1s un n\u00famero de registro de la aplicaci\u00f3n del estilo <code>ca-app-pub-6502933536055889~6323740433</code> </p> <p>Puedes encontrar tu ID de aplicaci\u00f3n en la interfaz de AdMob.</p> <p> </p>"},{"location":"teoria/anuncios/anuncios.html#importar-el-sdk-de-anuncios-para-moviles","title":"Importar el SDK de anuncios para m\u00f3viles","text":"<p>La forma m\u00e1s sencilla de importar el SDK a un proyecto iOS es mediante CocoaPods.</p> <p>Utilizando la instalaci\u00f3n de Ruby que viene por defecto en MacOS para instalar CocoaPods basta con hacer:</p> <pre><code>$ sudo gem install cocoapods\n</code></pre> <p>Supongamos que vamos a trabajar con la app ToDoList. En el directorio ra\u00edz del proyecto debes crear el fichero <code>Podfile</code>, con el contenido:</p> <pre><code>target 'ToDoList' do\n    pod 'Google-Mobile-Ads-SDK'\nend\n</code></pre> <p>Despu\u00e9s, desde l\u00ednea de comando y estando en el directorio ra\u00edz del proyecto, debes ejecutar:</p> <pre><code>$ pod install --repo-update\n</code></pre> <p>Se descargar\u00e1n las librer\u00edas necesarias y se crear\u00e1 un fichero <code>ToDoList.xcworkspace</code> que es el que debes abrir con Xcode. Al abrir este fichero Xcode abrir\u00e1 una configuraci\u00f3n de workspace en la que pueden existir m\u00e1s de un proyecto. Es la configuraci\u00f3n que se usa para trabajar con CocoaPods.</p>"},{"location":"teoria/anuncios/anuncios.html#actualizar-el-fichero-infoplist","title":"Actualizar el fichero Info.plist","text":"<p>A\u00f1ade una clave <code>GADApplicationIdentifier</code> con un valor de cadena igual a tu ID de aplicaci\u00f3n de AdMob al archivo <code>Info.plist</code> de tu aplicaci\u00f3n. Puedes encontrar tu ID de la aplicaci\u00f3n en la interfaz de AdMob.</p> <p>Puedes hacerlo editando el fichero:</p> <pre><code>&lt;key&gt;GADApplicationIdentifier&lt;/key&gt;\n&lt;string&gt;ca-app-pub-6502933536055889~6323740433&lt;/string&gt;\n</code></pre> <p>O usando la interfaz de Xcode:</p> <p> </p>"},{"location":"teoria/anuncios/anuncios.html#inicializacion-del-api","title":"Inicializaci\u00f3n del API","text":"<p>Antes de cargar anuncios, debemos inicializar el SDK de anuncios de Google para m\u00f3viles llamando al m\u00e9todo <code>start(ompletionHandler:)</code> de <code>GADMobileAds.sharedInstance()</code>, que inicializa el SDK y hace una retrollamada al controlador de finalizaci\u00f3n una vez que la inicializaci\u00f3n se ha completado, o bien despu\u00e9s de un tiempo de espera de 30 segundos. </p> <p>Solo es necesario hacerlo una vez, preferiblemente al iniciar la aplicaci\u00f3n. La llamada debe realizarse lo m\u00e1s pronto posible.</p> <p>A continuaci\u00f3n, tienes un ejemplo de c\u00f3mo llamar al m\u00e9todo startWithCompletionHandler: en tu AppDelegate:</p> <p>Ejemplo de <code>AppDelegate.swift</code> (fragmento)</p> <pre><code>import GoogleMobileAds\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication,\n                     didFinishLaunchingWithOptions launchOptions:\n                        [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n        // Override point for customization after application launch.\n        GADMobileAds.sharedInstance().start(completionHandler: nil)\n        return true\n    }\n}\n</code></pre>"},{"location":"teoria/anuncios/anuncios.html#seleccion-del-formato-de-anuncio","title":"Selecci\u00f3n del formato de anuncio","text":"<p>Tras importar e inicializar el SDK de anuncios para m\u00f3viles, podemos descargar un anuncio. AdMob ofrece diversos formatos de anuncios, y debemos elegir uno de ellos, el que mejor se ajuste a la experiencia de los usuarios de nuesra aplicaci\u00f3n.</p> <p>Dos de los m\u00e1s usados son de tipo banner y de tipo interstiticial.</p> <p>Banner</p> <p>Los anuncios de banner son anuncios rectangulares de imagen o de texto que ocupan parte de la pantalla de una aplicaci\u00f3n. Permanecen en pantalla mientras los usuarios interact\u00faan con la aplicaci\u00f3n y pueden actualizarse autom\u00e1ticamente despu\u00e9s de un cierto periodo de tiempo. Si es la primera vez que utilizamos la publicidad para m\u00f3viles, son un excelente punto de partida.</p> <p>Existen distintos tama\u00f1os de banners, que podemos seleccionar con su identificador:</p> Tama\u00f1o Descripci\u00f3n Disponibilidad Identificador 320x50 Banner Tel\u00e9fonos y tablets <code>kGADAdSizeBanner</code> 320x100 Banner grande Tel\u00e9fonos y tablets <code>kGADAdSizeLargeBanner</code> 300x250 Rect\u00e1ngulo mediano Tel\u00e9fonos y tablets <code>kGADAdSizeMediumRectangle</code> 468x60 Banner de tama\u00f1o completo Tablets <code>kGADAdSizeFullBanner</code> 728x90 Leaderboard Tablets <code>kGADAdSizeLeaderboard</code> <p>Intersticial</p> <p>Los intersticiales son anuncios que ocupan toda la pantalla y cubren la interfaz de una aplicaci\u00f3n hasta que el usuario los cierra. El mejor momento para usarlos son las pausas naturales de una aplicaci\u00f3n. Por ejemplo, al pasar de un nivel a otro en un juego o despu\u00e9s de completar una tarea.</p> <p>Veamos el c\u00f3digo para implementar un anuncio de cada uno de estos tipos.</p>"},{"location":"teoria/anuncios/anuncios.html#implementacion-de-un-banner","title":"Implementaci\u00f3n de un banner","text":"<p>Cuando probemos las aplicaciones debemos usar siempre anuncios de prueba en lugar de anuncios reales. De lo contrario, Google podr\u00eda suspender nuestra cuenta de AdMob.</p> <p>La forma m\u00e1s sencilla de cargar anuncios de prueba es mediante el ID de bloque de anuncios de prueba que Google ha creado para banners de iOS: <code>ca-app-pub-3940256099942544/2934735716</code>.</p> <p>Cuando publiquemos la app s\u00f3lo hay que sustituir este ID por el ID real.</p> <p>Los anuncios de banner se muestran en objetos <code>GADBannerView</code>, por lo que lo primero que debemos hacer para integrarlos es incluir un objeto <code>GADBannerView</code> en nuestra jerarqu\u00eda de vistas.</p> <p>Debemos actualizar las propiedades de este objeto:</p> <ul> <li><code>rootViewController</code>: controlador de vistas que se utiliza para   mostrar una superposici\u00f3n cuando se hace clic en el anuncio. Como   valor, normalmente se le da el controlador que contiene el    <code>GADBannerView</code>.</li> <li><code>adUnitID</code>: el objeto GADBannerView debe cargar anuncios procedentes   de este ID de bloque de anuncios.</li> <li><code>delegate</code>: delegado que implementa el protocolo   <code>GADBannerViewDelegate</code> que define las funciones en las que se   reciben los eventos del ciclo de vida de los anuncios.</li> </ul> <p>Tras configurar el <code>GADBannerView</code> y sus propiedades podemos cargar un anuncio. Para ello, se llama al m\u00e9todo <code>loadRequest</code> pasando un objeto <code>GADRequest</code>.</p> <p>Por ejemplo, el siguiente c\u00f3digo crea un objeto <code>GADBannerView</code> de tama\u00f1o 320x50 e inicializa las propiedades anteriores:</p> <pre><code>import UIKit\nimport GoogleMobileAds\n\nclass ViewController: UIViewController, GADBannerViewDelegate {\n    var bannerView: GADBannerView!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        bannerView = GADBannerView(adSize: kGADAdSizeBanner)\n        bannerView.adUnitID = \"ca-app-pub-3940256099942544/2934735716\"\n        bannerView.rootViewController = self\n        bannerView.load(GADRequest())\n        bannerView.delegate = self\n    }\n\n    ...\n}\n</code></pre> <p>En el siguiente m\u00e9todo <code>addBannerViewToView(_:)</code> se a\u00f1ade la vista del anuncio, aline\u00e1ndose con la parte inferior del \u00e1rea segura de pantalla:</p> <pre><code>func addBannerViewToView(_ bannerView: GADBannerView) {\n    bannerView.translatesAutoresizingMaskIntoConstraints = false\n    view.addSubview(bannerView)\n    view.addConstraints(\n        [NSLayoutConstraint(item: bannerView,\n                            attribute: .bottom,\n                            relatedBy: .equal,\n                            toItem: view.safeAreaLayoutGuide,\n                            attribute: .bottom,\n                            multiplier: 1,\n                            constant: 0),\n         NSLayoutConstraint(item: bannerView,\n                            attribute: .centerX,\n                            relatedBy: .equal,\n                            toItem: view,\n                            attribute: .centerX,\n                            multiplier: 1,\n                            constant: 0)\n    ])\n}\n</code></pre> <p>Por \u00faltimo, es recomendable realizar la llamada a la funci\u00f3n anterior que incorpora el <code>GADBannerView</code> a la jerarqu\u00eda de vistas despu\u00e9s de haber recibido un anuncio. Para ello, se usa la funci\u00f3n del delegado <code>adViewDidReceiveAd</code>:</p> <pre><code>    /// Tells the delegate an ad request loaded an ad.\n    func adViewDidReceiveAd(_ bannerView: GADBannerView) {\n        print(\"adViewDidReceiveAd\")\n        addBannerViewToView(bannerView)\n    }\n</code></pre> <p>Podemos implementar el resto de funciones del delegado, con sentencias <code>print</code> para depurar cuando se produce cada evento:</p> <pre><code>    /// Tells the delegate an ad request failed.\n    func adView(_ bannerView: GADBannerView,\n                didFailToReceiveAdWithError error: GADRequestError) {\n        print(\"adView:didFailToReceiveAdWithError: \\(error.localizedDescription)\")\n    }\n\n    /// Tells the delegate that a full-screen view will be presented in response\n    /// to the user clicking on an ad.\n    func adViewWillPresentScreen(_ bannerView: GADBannerView) {\n        print(\"adViewWillPresentScreen\")\n    }\n\n    /// Tells the delegate that the full-screen view will be dismissed.\n    func adViewWillDismissScreen(_ bannerView: GADBannerView) {\n        print(\"adViewWillDismissScreen\")\n    }\n\n    /// Tells the delegate that the full-screen view has been dismissed.\n    func adViewDidDismissScreen(_ bannerView: GADBannerView) {\n        print(\"adViewDidDismissScreen\")\n    }\n\n    /// Tells the delegate that a user click will open another app (such as\n    /// the App Store), backgrounding the current app.\n    func adViewWillLeaveApplication(_ bannerView: GADBannerView) {\n        print(\"adViewWillLeaveApplication\")\n    }\n</code></pre>"},{"location":"teoria/anuncios/anuncios.html#implementacion-de-un-interstitial","title":"Implementaci\u00f3n de un interstitial","text":"<p>Los anuncios intersticiales los solicitan y muestran los objetos <code>GADInterstitial</code>. </p> <p>Debemos crear una instancia y asignar el ID de su bloque de anuncios. Podemos cargar anuncios de prueba de tipo Interstitial usando el ID <code>ca-app-pub-3940256099942544/4411468910</code>.</p> <p>Por ejemplo, aqu\u00ed se muestra c\u00f3mo crear un <code>GADInterstitial</code> en el m\u00e9todo <code>viewDidLoad</code> de un <code>UIViewController</code>. Hacemos tambi\u00e9n que el interstitial lance una petici\u00f3n para cargar una anuncio, y definimos como delegado el view controller. Para ello el view controller debe cumplir el protocolo <code>GADInterstitialDelegate</code>.</p> <pre><code>import UIKit\nimport GoogleMobileAds\n\nclass ViewController: UIViewController, GADInterstitialDelegate {\n    var interstitial: GADInterstitial!\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        interstitial = GADInterstitial(adUnitID: \"ca-app-pub-3940256099942544/4411468910\")\n        interstitial.load(GADRequest())\n        interstitial.delegate = self\n    }\n\n    ...\n}\n</code></pre> <p><code>GADInterstitial</code> es un objeto de un solo uso que, al cargarse, muestra un anuncio intersticial. Para que una aplicaci\u00f3n muestre varios anuncios intersticiales, es necesario crear un <code>GADInterstitial</code> para cada uno de ellos (lo veremos m\u00e1s adelante).</p> <p>Para mostrar un intersticial, podemos verificar la propiedad <code>isReady</code> en <code>GADInterstitial</code> para asegurarnos de que ha terminado de cargarse y, despu\u00e9s, debemos llamar a <code>presentFromRootViewController</code> pas\u00e1ndole el view controller actual como view controller ra\u00edz:</p> <pre><code>  ...\n  if interstitial.isReady {\n    interstitial.present(fromRootViewController: self)\n  } else {\n    print(\"El anuncio no est\u00e1 disponible\")\n  }\n}\n</code></pre> <p>Al igual que hac\u00edamos en el banner podemos realizar esta llamada en la funci\u00f3n del delegado <code>interstitialDidReceiveAd</code>:</p> <pre><code>    /// Tells the delegate an ad request succeeded.\n    func interstitialDidReceiveAd(_ ad: GADInterstitial) {\n        print(\"interstitialDidReceiveAd\")\n        interstitial.present(fromRootViewController: self)\n    }\n</code></pre> <p>El resto de funciones del delegado son las siguientes:</p> <pre><code>/// Tells the delegate an ad request failed.\nfunc interstitial(_ ad: GADInterstitial, didFailToReceiveAdWithError error: GADRequestError) {\n  print(\"interstitial:didFailToReceiveAdWithError: \\(error.localizedDescription)\")\n}\n\n/// Tells the delegate that an interstitial will be presented.\nfunc interstitialWillPresentScreen(_ ad: GADInterstitial) {\n  print(\"interstitialWillPresentScreen\")\n}\n\n/// Tells the delegate the interstitial is to be animated off the screen.\nfunc interstitialWillDismissScreen(_ ad: GADInterstitial) {\n  print(\"interstitialWillDismissScreen\")\n}\n\n/// Tells the delegate the interstitial had been animated off the screen.\nfunc interstitialDidDismissScreen(_ ad: GADInterstitial) {\n  print(\"interstitialDidDismissScreen\")\n}\n\n/// Tells the delegate that a user click will open another app\n/// (such as the App Store), backgrounding the current app.\nfunc interstitialWillLeaveApplication(_ ad: GADInterstitial) {\n  print(\"interstitialWillLeaveApplication\")\n}\n</code></pre> <p>Tal y como hemos comentado el <code>GADInterstitial</code> es un objeto de un solo uso. Eso significa que una vez que se muestra un intersticial, <code>hasBeenUsed</code> devuelve el valor <code>true</code> y el intersticial no se puede usar para cargar otro anuncio. </p> <p>Para solicitar otro, deberemos crear un nuevo objeto <code>GADInterstitial</code>. Si intentamos reutilizar un objeto intersticial, aparecer\u00e1 el mensaje <code>\"Request Error: Will not send request because interstitial object has been used\"</code></p> <p>El mejor lugar para asignar otro intersticial es en el m\u00e9todo <code>interstitialDidDismissScreen</code> del delegado <code>GADInterstitialDelegate</code>, para que el siguiente intersticial comience a cargarse tan pronto como se cierre el anterior.</p> <p>Podemos refactorizar la creaci\u00f3n del interstiticial en una funci\u00f3n aparte, y llamar a esa funci\u00f3n desde <code>viewDidLoad</code> y desde <code>interstitialDidDismissScreen</code>:</p> <pre><code>override func viewDidLoad() {\n  super.viewDidLoad()\n  interstitial = createAndLoadInterstitial()\n}\n\nfunc createAndLoadInterstitial() -&gt; GADInterstitial {\n  var interstitial = GADInterstitial(adUnitID: \"ca-app-pub-3940256099942544/4411468910\")\n  interstitial.delegate = self\n  interstitial.load(GADRequest())\n  return interstitial\n}\n\nfunc interstitialDidDismissScreen(_ ad: GADInterstitial) {\n  interstitial = createAndLoadInterstitial()\n}\n</code></pre>"},{"location":"teoria/anuncios/anuncios.html#demo-aplicacion-de-prueba","title":"Demo: Aplicaci\u00f3n de prueba","text":"<p>Puedes descargarte una aplicaci\u00f3n de prueba en la que se muestra el funcionamiento b\u00e1sico de AdMob.</p> <p> </p> <p>Se debe ejecutar la app en un dispositivo real, ya que AdMob no funciona en el simulador. Tambi\u00e9n debes darte de alta en AdMob, registrar una aplicaci\u00f3n e incluir el n\u00famero de registro en el fichero <code>Info.plist</code>.</p>"},{"location":"teoria/anuncios/anuncios.html#referencias","title":"Referencias","text":"<ul> <li>Google AdMob SDK para iOS</li> </ul>"},{"location":"teoria/compras-in-app/compras-in-app.html","title":"Compras In-App","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#conceptos-de-compras-in-app","title":"Conceptos de compras In-App","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#que-es-una-compra-in-app","title":"\u00bfQu\u00e9 es una compra In-App?","text":"<p>Permite vender directamente una funcionalidad dentro de una app.</p> <p>Los datos de la compra (precio, identificador) se definen en iTunes Connect.</p> <p>Se implementa con el API StoreKit:</p> <ul> <li>StoreKit pregunta al usuario si confirma la transacci\u00f3n a trav\u00e9s del   acceso seguro del App Store.</li> <li>La app recibe la confirmaci\u00f3n de la compra y debe desbloquear   din\u00e1micamente la funcionalidad.</li> <li>La app debe guardar la informaci\u00f3n de que el usuario ha comprado esa   nueva funcionalidad, aunque el usuario siempre puede recuperar la   compra.</li> </ul> <p> </p>"},{"location":"teoria/compras-in-app/compras-in-app.html#ejemplos-de-uso","title":"Ejemplos de uso","text":"<p>Las compras In-App son una de las formas de monetizaci\u00f3n m\u00e1s usadas en la actualidad</p> <p>Por ejemplo:</p> <ul> <li>Podemos dar una versi\u00f3n b\u00e1sica gratuita y vender funcionalidades   adicionales premium.</li> <li>Podemos permitir la suscripci\u00f3n a contenidos peri\u00f3dicos que se pueden descargar<ul> <li>Ofertas de niveles adicionales en juegos</li> <li>Compras de mercanc\u00edas virtuales en juegos on-line</li> </ul> </li> </ul>"},{"location":"teoria/compras-in-app/compras-in-app.html#tipos-de-compras-in-app-compras","title":"Tipos de compras In-App - Compras","text":"<ul> <li>No-consumibles<ul> <li>\u00cdtems que permanecen disponibles de forma indefinida en todos los dispositivos del usuario.</li> <li>Ejemplos: libros, niveles de un juego, funcionalidades premium de un app.</li> </ul> </li> <li>Consumibles<ul> <li>\u00cdtems que se consumen durante el tipo de ejecuci\u00f3n del app.</li> <li>Ejemplos: minutos de llamadas de voz sobre IP, o servicios de un s\u00f3lo uso como transcripci\u00f3n de voz.</li> </ul> </li> </ul>"},{"location":"teoria/compras-in-app/compras-in-app.html#tipos-de-compras-in-app-suscripciones","title":"Tipos de compras In-App - Suscripciones","text":"<ul> <li>Suscripciones auto-renovables<ul> <li>Como los no-consumibles, las suscripciones permanecen   disponibles en todos los dispositivos. Tienen una fecha de   expiraci\u00f3n, en la que el sistema renueva autom\u00e1ticamente la   compra.</li> </ul> </li> <li>Suscripciones no-renovables<ul> <li>Suscripciones en las que no se entrega contenido peri\u00f3dico.</li> <li>Ejemplos: acceso a una base de datos de fotos hist\u00f3ricas.</li> <li>Suele acompa\u00f1arse de una cuenta de usuario en un servidor.</li> <li>La duraci\u00f3n y la expiraci\u00f3n de la suscripci\u00f3n se realizan desde   la app (y el servidor).</li> </ul> </li> </ul>"},{"location":"teoria/compras-in-app/compras-in-app.html#requisitos-para-activar-las-in-app","title":"Requisitos para activar las In-App","text":"<p>Las compras In-App s\u00f3lo pueden probarse y activarse con una cuenta de desarrollador de pago.</p> <p>Es necesario acceso a iTunes Connect para configurar las compras.</p> <p>No es posible hacerlo con el equipo de la universidad.</p> <p>Haremos una demo con una cuenta de desarrollador.</p>"},{"location":"teoria/compras-in-app/compras-in-app.html#contratos","title":"Contratos","text":"<p>\u00a1Cuidado!: Para poder probar las compras In-App hay que tener todos los contratos en regla.</p> <p> </p>"},{"location":"teoria/compras-in-app/compras-in-app.html#servicios-a-activar-en-la-app","title":"Servicios a activar en la app","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#bundle-identifier-y-app-id","title":"Bundle identifier y App Id","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#configuracion-in-app-desde-itunes-connect","title":"Configuraci\u00f3n In-App desde iTunes Connect","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#datos-del-app","title":"Datos del app","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#pantalla-para-anadir-nuevos-in-apps","title":"Pantalla para a\u00f1adir nuevos In-Apps","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#seleccionar-el-tipo-de-in-app","title":"Seleccionar el tipo de In-App","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#caracteristicas-del-in-app","title":"Caracter\u00edsticas del In-App","text":"<ul> <li>Nombre de referencia: aparece en la ventana de compra</li> <li>ID del producto: identificador del In-App para reconocerlo en el app</li> <li>Precio</li> <li>Datos para la revisi\u00f3n de Apple</li> </ul>"},{"location":"teoria/compras-in-app/compras-in-app.html#caracteristicas-del-in-app_1","title":"Caracter\u00edsticas del In-App","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#usuarios-de-prueba","title":"Usuarios de prueba","text":"<p>Para probar las compras In-App debemos crear usuarios de prueba de sandbox en iTunes Connect.</p> <p>En el dispositivo de prueba hay que iniciar la sesi\u00f3n en el App Store con ese usuario de prueba.</p> <p> </p> <p> </p>"},{"location":"teoria/compras-in-app/compras-in-app.html#demo","title":"Demo","text":"<p>Vamos a ver un ejemplo de aplicaci\u00f3n que contiene una pantalla sorpresa cuyo acceso se activa con una compra In-App.</p> <p>Est\u00e1 disponible en este enlace</p> <p> </p> <p> </p>"},{"location":"teoria/compras-in-app/compras-in-app.html#codigo-para-implementar-las-compras-in-app","title":"C\u00f3digo para implementar las compras In-App","text":""},{"location":"teoria/compras-in-app/compras-in-app.html#el-proceso-de-compra-en-un-vistazo","title":"El proceso de compra en un vistazo","text":"<p>Debemos implementar los protocolos <code>SKProductsRequestDelegate</code> y <code>SKPaymentTransactionObserver</code>.</p> <p> </p>"},{"location":"teoria/compras-in-app/compras-in-app.html#clase-auxiliar-inapp","title":"Clase auxiliar InApp","text":"<p>Creamos un protocolo <code>InAppDelegate</code> y una clase <code>InApp</code> donde gestionaremos la interacci\u00f3n con <code>StoreKit</code>:</p> <pre><code>import Foundation\nimport StoreKit\n\nprotocol InAppDelegate {\n    func compraRecibida()\n}\n\nclass InApp: NSObject, SKProductsRequestDelegate, SKPaymentTransactionObserver {\n    var productDetailsList: [SKProduct] = []\n    var productIdentiferList: [String] = []\n    var delegate: InAppDelegate?\n\n    override init() {\n        super.init()\n        SKPaymentQueue.default().add(self)\n\n        // Cargamos la lista de productos\n\n        productIdentiferList.append(\"ejemplo3\")\n        let request = SKProductsRequest.init(productIdentifiers: Set(productIdentiferList))\n        request.delegate = self\n        request.start()\n    }\n\n    // M\u00e9todo para lanzar la petici\u00f3n de compra al usuario\n    func lanzarPago() {\n        if (self.productDetailsList.count &gt; 0 &amp;&amp;  SKPaymentQueue.canMakePayments()) {\n            let producto = productDetailsList[0]\n            let pago = SKPayment(product: producto)\n            SKPaymentQueue.default().add(pago)\n            print(\"Comprando...\")\n        } else {\n            print(\"No existen productos\")\n        }\n    }\n\n    // M\u00e9todo al que se llama cuando el usuario compra el InApp\n\n    func paymentQueue(_ queue: SKPaymentQueue,\n                      updatedTransactions transactions: [SKPaymentTransaction]) {\n        for transaction in transactions {\n            switch transaction.transactionState {\n            case .purchased:\n                print(\"Purchased\")\n                delegate?.compraRecibida()\n                SKPaymentQueue.default().finishTransaction(transaction)\n            case .failed:\n                print(\"Failed\")\n                print(\"Error de transacci\u00f3n: \\(String(describing: transaction.error?.localizedDescription))\")\n                SKPaymentQueue.default().finishTransaction(transaction)\n            case .restored:\n                print(\"Restored\")\n                delegate?.compraRecibida()\n                SKPaymentQueue.default().finishTransaction(transaction)\n            default:\n                print(\"Otro\")\n            }\n        }\n    }\n\n    // M\u00e9todo al que se llama cuando se han recibido los productos\n\n    func productsRequest(_ request: SKProductsRequest, \n                         didReceive response: SKProductsResponse) {\n        print(\"Hemos recibido \\(response.products.count) productos\")\n        productDetailsList = response.products\n        for invalidProductId in response.invalidProductIdentifiers {\n            print(\"Producto invalido id: \\(invalidProductId)\")\n        }\n    }\n}\n</code></pre>"},{"location":"teoria/compras-in-app/compras-in-app.html#clase-viewcontroller","title":"Clase ViewController","text":"<p>En la clase <code>ViewController</code> adoptamos nuestro protocolo <code>InAppDelegate</code> y definimos su m\u00e9todo <code>compraRecibida()</code> al que se va a llamar cuando se haya recibido y validado la compra.</p> <pre><code>import UIKit\n\nclass ViewController: UIViewController, InAppDelegate {\n\n    @IBOutlet weak var botonSorpresa: UIButton!\n    let inApp = InApp()\n\n    override func viewDidLoad() {\n        // Actualizamos el delgado de inApp con la propia\n        // instacia, para que se llame al m\u00e9todo compraRecibida\n        inApp.delegate = self\n\n        // Escondemos el bot\u00f3n sorpresa, que s\u00f3lo estar\u00e1 visible\n        // para los que hagan la compra\n        botonSorpresa.isHidden = true\n\n        // Comprobamos si hemos comprado antes el inApp\n        if UserDefaults.standard.bool(forKey: \"inAppComprado\") {\n            botonSorpresa.isHidden = false\n        } else {\n            botonSorpresa.isHidden = true\n        }\n        super.viewDidLoad()\n    }\n\n    // M\u00e9todo del protocolo al que se va a llamar cuando se reciba\n    // la compra. Hacemos visible el bot\u00f3n sorpresa.\n    func compraRecibida() {\n        botonSorpresa.isHidden = false\n    }\n\n    // La acci\u00f3n asociada al bot\u00f3n de compra llama\n    // al m\u00e9todo lanzarPago de la instancia de nuestra\n    // clase InApp\n    @IBAction func hazCompra(_ sender: UIButton) {\n        print(\"Click bot\u00f3n de compra\")\n        inApp.lanzarPago()\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n\n    // Acci\u00f3n para mostrar la pantalla sorpresa\n    @IBAction func sorpresa(_ sender: UIButton){\n        performSegue(withIdentifier: \"Sorpresa\", sender: view)\n    }\n}\n</code></pre>"},{"location":"teoria/compras-in-app/compras-in-app.html#referencias","title":"Referencias","text":"<ul> <li>P\u00e1gina resumen Apple Developer</li> <li>App Store Connect - In-App purchase</li> <li>In-App Purchase Programming Guide</li> <li>Receipt Validation Programming Guide</li> <li>StoreKit Framework Reference</li> <li>Technical Note: Adding In-App Purchase to your iOS and OS X Applications</li> <li>Technical Note: In-App Purchase Best Practices</li> </ul>"},{"location":"teoria/extensiones/extensiones.html","title":"Extensiones","text":""},{"location":"teoria/extensiones/extensiones.html#conceptos-basicos","title":"Conceptos b\u00e1sicos","text":""},{"location":"teoria/extensiones/extensiones.html#introduccion","title":"Introducci\u00f3n","text":"<p>Las app extensions representan peque\u00f1as apps o peque\u00f1os hilos de ejecuci\u00f3n que se instalan en puntos de extensi\u00f3n del sistema y de otras apps.</p> <p>Se distribuyen e instalan junto con apps normales (la app contenedora de la extensi\u00f3n), no de forma independiente (con la excepci\u00f3n de los teclados configurables). Por ejemplo, Pocket distribuye una extensi\u00f3n para guardar contenido en la app cuando el usuario pulsa el bot\u00f3n de compartir estando en una p\u00e1gina web.</p> <p>Pueden llegar a ser importantes para el usuario final, proporcionando integraci\u00f3n entre apps y aumentando la experiencia de usuario.</p> <p>En nuestras apps podemos tambi\u00e9n declarar puntos de extensi\u00f3n a los que se conectar\u00e1n extensiones de terceros (compartir, por ejemplo).</p>"},{"location":"teoria/extensiones/extensiones.html#targets","title":"Targets","text":"<p>Las extensiones se incluyen en el proyecto como targets adicionales que acompa\u00f1an a la app principal.</p> <p>Un target especifica un producto a construir por Xcode. Por ejemplo, si cuando creamos un proyecto escogemos a\u00f1adir tests unitarios y de UI, Xcode introduce autom\u00e1ticamente estos targets, adem\u00e1s de la app principal.</p> <p>Para a\u00f1adir manualmente un nuevo target al proyecto podemos seleccionar el bot\u00f3n <code>+</code> en la parte de abajo o la opci\u00f3n Editor &gt; Add Target....</p> <p> </p> <p>Podemos seleccionar el target y especificar sus caracter\u00edsticas en el panel principal. Hay que especificar los mismos elementos que para una app principal (de hecho los targets son como mini apps):</p> <ul> <li>Bundle Id, versi\u00f3n, build</li> <li>Certificado y perfil de aprovisionamiento</li> <li>Permisos (capabilities)</li> <li>Configuraci\u00f3n y reglas del build</li> </ul>"},{"location":"teoria/extensiones/extensiones.html#esquema","title":"Esquema","text":"<p>Cada target tiene una configuraci\u00f3n autom\u00e1tica de construcci\u00f3n definida por su esquema (schema).</p> <p>Un esquema es una colecci\u00f3n de configuraciones que especifican las acciones a realizar para la compilaci\u00f3n del target y el entorno ejecutable a usar para lanzar el producto.</p> <p>Cuando abrimos o creamos un proyecto, Xcode crea autom\u00e1ticamente un esquema para cada target.</p> <p>El men\u00fa de esquemas se puede usar para cambiar el esquema activo y el destino. Podemos usar tambi\u00e9n el men\u00fa de esquemas para crear, editar y gestionar esquemas y para a\u00f1adir y descartar simuladores.</p> <p> </p> <p>Los esquemas y los destinos son distintos. Los destinos especifican d\u00f3nde instalar la app (dispositivos f\u00edsicos y simuladores).</p> <p> </p> <p>Los esquemas especifican los ajustes para compilar, ejecutar, testear, monitorizar, analizar y archivar el proyecto. Estos ajustes se pueden configurar en la opci\u00f3n de editar esquema.</p> <p> </p>"},{"location":"teoria/extensiones/extensiones.html#ejemplo-de-extension-compartir","title":"Ejemplo de extensi\u00f3n: Compartir","text":"<p>Veamos un ejemplo concreto, la extensi\u00f3n Compartir (Share Extension).</p> <p></p> <p>Muchas aplicaciones proporcionan el punto de extensi\u00f3n Compartir, en el que se pueden instalar extensiones de tipo Share Extension. Por ejemplo, en la siguiente imagen vemos como se puede acceder a la opci\u00f3n de compartir en una p\u00e1gina del navegador Safari y c\u00f3mo el usuario puede acceder a las extensiones que se han a\u00f1adido.</p> <p> </p> <p>La extensi\u00f3n Compartir hereda un <code>ViewController</code> por defecto de tipo <code>SLComposeServiceViewController</code> que contiene entre otros:</p> <ul> <li>Un campo de texto que puede editar el usuario, </li> <li>Una previsualizaci\u00f3n del objeto a compartir</li> <li>Los botones <code>Cancel</code> y <code>Post</code></li> </ul> <p> </p> <p>La extensi\u00f3n puede configurar algunos aspectos de este <code>ViewController</code>. Por ejemplo, puede a\u00f1adir una opci\u00f3n en la parte inferior en la que el usuario pueda seleccionar d\u00f3nde compartir.</p> <p>Por ejemplo, esto se hace en la extensi\u00f3n adaptada por la app <code>Recordatorios</code>, en la que se da la opci\u00f3n de seleccionar el recordatorio en el que se quiere a\u00f1adir la p\u00e1gina.</p> <p> </p>"},{"location":"teoria/extensiones/extensiones.html#slcomposeserviceviewcontroller","title":"SLComposeServiceViewController","text":"<p>Cuando creamos una extensi\u00f3n (m\u00e1s adelante haremos una demostraci\u00f3n) Xcode crea una plantilla inicial de c\u00f3digo.</p> <p>En el caso de una extensi\u00f3n <code>Compartir</code> la plantilla define un view controller hijo de <code>SLComposeServiceViewController</code> en el que podemos configurar el funcionamiento de la extensi\u00f3n.</p> <pre><code>import UIKit\nimport Social\n\nclass ShareViewController: SLComposeServiceViewController {\n\n    override func isContentValid() -&gt; Bool {\n        // Do validation of contentText and/or NSExtensionContext \n        // attachments here\n        return true\n    }\n\n    override func didSelectPost() {\n        // This is called after the user selects Post. Do the \n        // upload of contentText and/or NSExtensionContext \n        // attachments.\n\n        // Inform the host that we're done, so it un-blocks its UI. \n        // Note: Alternatively you could call super's -didSelectPost,\n        // which will similarly complete the extension context.\n        self.extensionContext!.completeRequest(returningItems: [], \n                                               completionHandler: nil)\n    }\n\n    override func configurationItems() -&gt; [Any]! {\n        // To add configuration options via table cells at the\n        // bottom of the sheet, return an array of \n        // SLComposeSheetConfigurationItem here.\n        return []\n    }\n}\n</code></pre>"},{"location":"teoria/extensiones/extensiones.html#extension-context","title":"Extension Context","text":"<p>La aplicaci\u00f3n que invoca a la extensi\u00f3n crea un objeto de tipo NSExtensionContext que se guarda en la variable <code>extensionContext</code> del <code>SLComposeServiceViewController</code>.</p> <p>Este objeto contiene la informaci\u00f3n del \u00edtem o \u00edtems que el usuario a seleccionado para compartir en su propiedad <code>inputItems</code>:</p> <ul> <li><code>var inputItems : [Any]</code></li> </ul>"},{"location":"teoria/extensiones/extensiones.html#creacion-de-extensiones-dentro-de-apps","title":"Creaci\u00f3n de extensiones dentro de apps","text":"<p>Las extensiones se crean en Xcode seleccionando el proyecto y la opci\u00f3n Editor &gt; Add Target...</p> <p>Hay plantillas para todos los tipos de extensiones que proporcionan un punto de partida a partir del que desarrollar nuestra extensi\u00f3n.</p> <p> </p>"},{"location":"teoria/extensiones/extensiones.html#se-construyen-de-forma-independiente","title":"Se construyen de forma independiente","text":"<p>Las extensiones se compilan de forma independiente de la app.</p> <p>Tienen su propio bundle id, capabilities, perfil de aprovisionamiento, etc.</p> <p>En el caso de la pr\u00e1ctica, el bundle id de la extensi\u00f3n ser\u00e1: <code>es.ua.mastermoviles.ToDoListCloudKit.Hecho</code>.</p> <p>Para poder depurarlas o que aparezca su salida en el panel de salida est\u00e1ndar de Xcode hay que seleccionarla como producto a lanzar en el simulador.</p>"},{"location":"teoria/extensiones/extensiones.html#demo-extension-compartir","title":"Demo: Extensi\u00f3n Compartir","text":"<p>Vamos a crear una extensi\u00f3n Compartir desde cero.</p> <ol> <li>Creamos un proyecto nuevo llamado <code>PruebaExtension</code> y a\u00f1adimos un nuevo target. Elegimos el tipo de extensi\u00f3n Share Extension:</li> </ol> <p> </p> <ol> <li>Escribimos como nombre del producto <code>Compartir</code> y aceptamos activar    el esquema <code>Compartir</code>.</li> </ol> <p> </p> <ol> <li> <p>Comprobamos los dos productos existentes, el c\u00f3digo de cada uno de    ellos, y los esquemas. </p> <p>A\u00f1adimos en el storyboard de la app principal una etiqueta    que deber\u00e1 aparecer cuando la app est\u00e9 lanzada en el simulador.</p> <p>A\u00f1adimos c\u00f3digo en el view controller creado por defecto para    la extensi\u00f3n en el que imprimimos algunos mensajes en la salida    est\u00e1ndar. </p> </li> </ol> <p> </p> <ol> <li>Podemos instalar y depurar la extensi\u00f3n seleccionando el esquema y    ejecut\u00e1ndolo. Aparece un panel en el que tenemos que seleccionar la    app compa\u00f1era de la extensi\u00f3n (cualquier extensi\u00f3n debe    instalarse junto con una app principal). </li> </ol> <p>Podemos escoger cualquier app de las ya instaladas. Lo m\u00e1s normal    es que instalemos primero la app principal y despu\u00e9s ejecutemos la    extensi\u00f3n usando esta app.</p> <p> </p> <ol> <li>Cuando se lance la app principal, ya se habr\u00e1 cargado la    extensi\u00f3n. Abrimos Safari, por ejemplo, y escogemos la opci\u00f3n    compartir. Comprobamos si la extensi\u00f3n est\u00e1 habilitada.</li> </ol> <p> </p> <ol> <li>Pulsamos la extensi\u00f3n <code>Compartir</code> y vemos c\u00f3mo se activa su view    controller y como aparecen en la consola los mensajes que hemos    a\u00f1adido en el c\u00f3digo.</li> </ol> <p> </p>"},{"location":"teoria/extensiones/extensiones.html#tipos-de-extensiones","title":"Tipos de extensiones","text":""},{"location":"teoria/extensiones/extensiones.html#puntos-de-extension","title":"Puntos de extensi\u00f3n","text":"<p>Cada uno de los tipos de extensiones anteriores se conectan con puntos de extensi\u00f3n del sistema.</p> <p>Cada punto de extensi\u00f3n define una pol\u00edtica de uso y proporciona APIs que se usan en las extensiones de ese tipo.</p> <p>Cada punto de extensi\u00f3n permite una funcionalidad distinta. Cuando dise\u00f1emos una extensi\u00f3n hay que identificar qu\u00e9 funcionalidad queremos ofrecer y qu\u00e9 punto de extensi\u00f3n debemos usar.</p> <p>Se puede consultar la lista completa de puntos de extensi\u00f3n en la documentaci\u00f3n de Apple.</p> <p>Algunos de los tipos de extensiones que proporciona el sistema:</p> <ul> <li>Actions: Permite manipular contenido de la app original</li> <li>Audio Unit: Permite generar o modificar un stream de audio</li> <li>Custom Keyboard: Permite reemplazar el teclado del sistema con   un teclado customizado</li> <li>Document Provider: Permite acceder y gestionar un repositorio de ficheros</li> <li>Intents: Manejar tareas relacionadas con la integraci\u00f3n con Siri.</li> <li>Photo Editing: Permite editar una foto o un v\u00eddeo en la app <code>Fotos</code></li> <li>Share: Permite enviar a un sitio web o compartir contenido con otros</li> <li>Today: Permite a\u00f1adir widgets en el panel de Hoy</li> <li>WatchKit App: Proporcionar una app o una notificaci\u00f3n UI para el Apple Watch.</li> </ul> <p>Xcode permite a\u00f1adir un target que implementa cualquiera de las extensiones anteriores, creando el c\u00f3digo y la configuraci\u00f3n inicial de la misma.</p> <p>Un ejemplo del aspecto de las extensiones <code>Custom Keyboard</code> y <code>Photo Editing</code>:</p> <p> </p>"},{"location":"teoria/extensiones/extensiones.html#propiedades-de-la-extension","title":"Propiedades de la extensi\u00f3n","text":"<p>Todos los aspectos relacionados con la configuraci\u00f3n de la extensi\u00f3n, incluido su tipo, se definen en propiedades en el fichero <code>Info.plist</code>.</p> <p>Por ejemplo, la extensi\u00f3n Share a\u00f1adida en la demostraci\u00f3n se crea con las siguientes propiedades:</p> <pre><code>    &lt;key&gt;NSExtension&lt;/key&gt;\n&lt;dict&gt;\n&lt;key&gt;NSExtensionAttributes&lt;/key&gt;\n&lt;dict&gt;\n&lt;key&gt;NSExtensionActivationRule&lt;/key&gt;\n&lt;string&gt;TRUEPREDICATE&lt;/string&gt;\n&lt;/dict&gt;\n&lt;key&gt;NSExtensionMainStoryboard&lt;/key&gt;\n&lt;string&gt;MainInterface&lt;/string&gt;\n&lt;key&gt;NSExtensionPointIdentifier&lt;/key&gt;\n&lt;string&gt;com.apple.share-services&lt;/string&gt;\n&lt;/dict&gt;\n</code></pre> <p>La propiedad <code>NSExtensionPointIdentifier</code> es la que define el tipo de extensi\u00f3n y el punto de extensi\u00f3n. Como vemos, en el caso de una extensi\u00f3n de tipo Share es <code>com.apple.share-services</code>. </p>"},{"location":"teoria/extensiones/extensiones.html#panel-today","title":"Panel <code>Today</code>","text":"<p>Veamos algunas caracter\u00edsticas de otro tipo de extensi\u00f3n, la Today Extension.</p> <p></p> <p>En iOS los usuarios pueden visualizar un panel especial, denominado <code>Today</code>, en el que es posible instalar extensiones. Se accede a este panel con un gesto de deslizar hacia la derecha, incluso con el dispositivo bloqueado. </p> <p> </p> <p>Las extensiones tienen una peque\u00f1a vista que se muestran apiladas una sobre otra. Tambi\u00e9n se puede acceder a una segunda vista ampliada al pulsar Mostrar m\u00e1s.</p> <p>El usuario puede configurar el orden en que aparecen las extensiones y activarlas o esconderlas.</p>"},{"location":"teoria/extensiones/extensiones.html#notification-service-extension","title":"Notification Service Extension","text":"<p>Veamos un \u00faltimo ejemplo de extensi\u00f3n, la Notification Service Extension.</p> <p></p> <p>La Notification Service Extension es una extensi\u00f3n que permite modificar el contenido de una notificaci\u00f3n remota que llega al dispositivo, antes de ser mostrada.</p> <p>Hay que seleccionar el tipo en Xcode y se a\u00f1ade un nuevo target a la aplicaci\u00f3n. En este caso Xcode no genera ninguna vista ni controller, s\u00f3lo una clase <code>NotificationService</code> que extiende <code>UNNotificationServiceExtension</code> y que debemos modificar.</p> <pre><code>import UserNotifications\n\nclass NotificationService: UNNotificationServiceExtension {\n\n    var contentHandler: ((UNNotificationContent) -&gt; Void)?\n    var bestAttemptContent: UNMutableNotificationContent?\n\n    override func didReceive(_ request: UNNotificationRequest, \n                             withContentHandler contentHandler: \n                             @escaping (UNNotificationContent) -&gt; Void) {\n        self.contentHandler = contentHandler\n        bestAttemptContent = (request.content.mutableCopy() as? \n                                       UNMutableNotificationContent)\n\n        if let bestAttemptContent = bestAttemptContent {\n            // Modify the notification content here...\n            bestAttemptContent.title = \n                    \"\\(bestAttemptContent.title) [modified]\"\n\n            contentHandler(bestAttemptContent)\n        }\n    }\n\n    override func serviceExtensionTimeWillExpire() {\n        // Called just before the extension will be terminated by \n        // the system.\n        // Use this as an opportunity to deliver your \"best attempt\" \n        // at modified content, otherwise the original push payload \n        // will be used.\n        if let contentHandler = contentHandler, \n           let bestAttemptContent =  bestAttemptContent {\n            contentHandler(bestAttemptContent)\n        }\n    }\n}\n</code></pre> <p>Se debe usar el m\u00e9todo <code>didReceiveNotificationRequest:withContentHandler:</code> para crear un nuevo objeto <code>UNMutableNotificationContent</code> en el que se pueden realizar los cambios que se deseen, reemplazando algunos o todos de los valores originales.</p> <p>Cuando se haya terminado, se debe llamar al manejador proporcionado pas\u00e1ndole el nuevo objeto. El sistema integra el nuevo contenido en la notificaci\u00f3n y la entrega al usuario.</p>"},{"location":"teoria/extensiones/extensiones.html#funcionamiento-de-una-extension","title":"Funcionamiento de una extensi\u00f3n","text":""},{"location":"teoria/extensiones/extensiones.html#ciclo-de-vida-de-una-extension","title":"Ciclo de vida de una extension","text":"<p>Las app extensi\u00f3n tienen un ciclo de vida muy corto. </p> <p>Se inicia cuando el usuario la elige de la IU de la app anfitriona. La app anfitriona define el contexto proporcionado a la extensi\u00f3n y comienza el ciclo de vida de la extensi\u00f3n, lanz\u00e1ndole una petici\u00f3n en respuesta a una acci\u00f3n del usuario. </p> <p>Si la extensi\u00f3n tiene un ViewController, el sistema llama al m\u00e9todo <code>viewDidLoad()</code> para inicializar la vista y permitir que el usuario interaccione con ella.</p> <p>La extensi\u00f3n termina tan pronto como completa la petici\u00f3n que ha recibido de la app anfitriona.</p> <p>Ejemplo: el usuario escribe un texto, lo selecciona y pulsa el bot\u00f3n compartir para enviarlo a una red social.</p>"},{"location":"teoria/extensiones/extensiones.html#comunicacion-de-la-app-extension","title":"Comunicaci\u00f3n de la app extension","text":"<p>Una app extension se comunica principalmente con su app anfitriona (la app desde la que se lanza la extensi\u00f3n).</p> <p>No hay comunicaci\u00f3n directa entre la extensi\u00f3n y la app contenedora. La app contenedora ni siquiera estar\u00e1 ejecut\u00e1ndose cuando la extensi\u00f3n est\u00e9 corriendo.</p> <p>El sistema abre la app extension en respuesta a la app anfitriona y la extensi\u00f3n toma sus datos de un contexto proporcionado por esta app. Como ya hemos visto, un objeto del tipo <code>NSExtensionContext</code>.</p> <p>Una extensi\u00f3n de tipo <code>Today</code> (y ninguna otra) puede pedir al sistema que abra la app contenedora.</p>"},{"location":"teoria/extensiones/extensiones.html#comunicacion-entre-la-app-y-la-extension","title":"Comunicaci\u00f3n entre la app y la extensi\u00f3n","text":"<p>La extensi\u00f3n y su app contenedora pueden comunicarse a trav\u00e9s de datos compartidos en un contenedor compartido. Veamos posibles formas de hacerlo.</p> <p> </p> <p>La app y la extensi\u00f3n se ejecutan en diferentes procesos y tambi\u00e9n en diferentes contenedores.</p> <p>Es posible compartir c\u00f3digo usando:</p> <ul> <li>frameworks embebidos compartidos</li> <li>grupos de apps</li> <li>a trav\u00e9s de una persistencia com\u00fan, usando CoreData o sqlite</li> </ul>"},{"location":"teoria/extensiones/extensiones.html#framework-embebido-para-compartir-codigo","title":"Framework embebido para compartir c\u00f3digo","text":"<p>Un framework embebido permite compartir c\u00f3digo entre la extensi\u00f3n y la app contenedora.</p> <p>Por ejemplo, si se desarrolla c\u00f3digo para realizar un filtro de una foto es conveniente poner el c\u00f3digo en un framework y embeber ese framework tanto en la extensi\u00f3n como en su app contenedora.</p> <p>Para crear un framework embebido se debe seleccionar \"Frameworks\" como   destino en la fase de construcci\u00f3n Copy Files.</p>"},{"location":"teoria/extensiones/extensiones.html#grupos-de-apps","title":"Grupos de apps","text":"<p>Los grupos de apps permiten que distintas apps y extensiones de un mismo desarrollador puedan acceder a recursos compartidas entre todas ellas, como:</p> <ul> <li>UserDefaults compartido</li> <li>Ficheros compartidos</li> </ul> <p>Un grupo de app se define con un identificador y se crea en el centro de desarrolladores. Tambi\u00e9n lo puede crear autom\u00e1ticamente Xcode en la opci\u00f3n App Groups en las capabilities.</p> <p>Todas las apps y extensiones deben usar ese mismo identificador de grupo en su App Id (configurado en el centro de desarrolladoras) y en sus capabilities (en Xcode).</p>"},{"location":"teoria/extensiones/extensiones.html#configuracion-del-grupo-de-apps","title":"Configuraci\u00f3n del grupo de apps","text":"<p>Hay que crear un grupo de app en el centro de desarrolladores (dando el identificador) e incluir ese grupo en el App Id que usaremos en la app y en la extensi\u00f3n.</p> <p>Creamos para la pr\u00e1ctica el grupo <code>group.ua.mastermoviles.ToDoList</code></p>"},{"location":"teoria/extensiones/extensiones.html#app-ids-y-perfiles-de-aprovisionamiento","title":"App IDs y perfiles de aprovisionamiento","text":"<p>Para la pr\u00e1ctica actualizamos los App IDs y los perfiles de aprovisionamiento, creando el App ID y el perfil <code>Master Moviles ToDoList Extension</code> y a\u00f1adiendo el identificador de grupo compartido entre este App Id y el <code>Master Moviles ToDoList</code>.</p> <p>App IDs:</p> <ul> <li><code>Master Moviles ToDoList</code> con el bundle ID <code>es.ua.mastermoviles.ToDoList</code></li> <li><code>ToDoList Today Extension</code> con el bundle ID <code>es.ua.mastermoviles.ToDoList.Hecho</code></li> </ul> <p>Perfiles de aprovisionamiento: </p> <ul> <li><code>Master Moviles ToDoList</code></li> <li><code>ToDoList Today Extension</code></li> </ul>"},{"location":"teoria/extensiones/extensiones.html#capabilities","title":"Capabilities","text":"<p>Tanto en la extensi\u00f3n como en la app hay que activar la capability App Groups y escribir el identificador del grupo que hemos definido.</p>"},{"location":"teoria/extensiones/extensiones.html#compartir-datos-con-userdefaults","title":"Compartir datos con UserDefaults","text":"<p>La clase UserDefaults define un diccionario compartido en el que se puede guardar valores asociados a claves.</p> <pre><code>let compartido = UserDefaults(suiteName: \"group.app.group.id\")\n\n// set valores\n\ncompartido?.set(1, forKey: \"contador\")\ncompartido?.synchronize()\n\n// get valores\n\ncompartido?.synchronize ();\nlet contador = compartido?.integer(forKey: \"contador\")\n</code></pre>"},{"location":"teoria/extensiones/extensiones.html#compartir-datos-con-filemanager","title":"Compartir datos con <code>FileManager</code>","text":"<p>La clase <code>FileManager</code> contiene el m\u00e9todo <code>containerURL</code> al que se le debe pasar el identificador del grupo de apps y que devuelve una URL con la localizaci\u00f3n del directorio compartido del grupo en el sistema de ficheros.</p> <p>Es posible crear ficheros compartidos con todas las apps del grupo en este directorio.</p> <pre><code>let fileManager = FileManager.default\nif let containerURL = fileManager.\n    containerURL(forSecurityApplicationGroupIdentifier: \n                    \"group.com.company.project\") {\n    ...\n}\n</code></pre>"},{"location":"teoria/extensiones/extensiones.html#demo-customnotes","title":"Demo: CustomNotes","text":"<p>Veamos un ejemplo completo de extensi\u00f3n de tipo Share Extension, la app CustomNotes, adaptada de una versi\u00f3n original hecha con Swift 3 y disponible en github. La aplicaci\u00f3n original se describe en este art\u00edculo de Medium. </p> <p>Se ha modificado la app original, simplific\u00e1ndola y adapt\u00e1ndola a Swift 5. La puedes descargar desde este enlace.</p> <p> </p> <p> </p> <p>Algunas caracter\u00edsticas interesantes:</p> <ul> <li>Utiliza Core Data para guardar las notas.</li> <li>Define un grupo de app compartido entre la extensi\u00f3n y la app en el   que se guardan los datos.</li> <li>Permite seleccionar la nota en la que se guarda el texto a compartir.</li> </ul> <p>Examinamos c\u00f3mo funcionan la app y la extensi\u00f3n.</p>"},{"location":"teoria/extensiones/extensiones.html#referencias","title":"Referencias","text":"<ul> <li>P\u00e1gina de principal de Apple: App Extensions</li> <li>App Extensions Programming Guide</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html","title":"Firma, aprovisionamiento y distribuci\u00f3n de apps","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#introduccion","title":"Introducci\u00f3n","text":"<p>En la sesi\u00f3n de hoy estudiaremos los elementos que proporciona la plataforma iOS para:</p> <ul> <li>Ejecutar apps en dispositivos reales.</li> <li>Configurar perfiles de aprovisionamiento en el Programa de   Desarrollo de la Universidad que nos permitan:<ul> <li>Distribuir nuestras apps en dispositivos de prueba.</li> <li>Utilizar APIs de los servicios de iOS no disponibles en la cuenta   de desarrollador gratuita. </li> </ul> </li> <li>Probar y distribuir apps usando Test Flight y App Store Connect.</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#seguridad-en-las-apps","title":"Seguridad en las apps","text":"<p>La seguridad es uno de los elementos fundamentales de la plataforma iOS. En concreto, el sistema de instalaci\u00f3n y ejecuci\u00f3n de apps en dispositivos reales contempla la necesidad de que las apps se ejecuten de forma segura y sin comprometer la integridad de la plataforma, eliminando virus, malware o ataques no autorizados.</p> <p>El documento iOS Security Guide detalla todos los elementos que conforman la seguridad de la plataforma. Uno de los elementos m\u00e1s cr\u00edticos de la arquitectura son las apps.</p> <p>Para garantizar la autor\u00eda del desarrollador y la no modificaci\u00f3n del c\u00f3digo, todo el c\u00f3digo ejecutable que se ejecute en un dispositivo iOS debe haber sido firmado con un certificado generado por Apple. Al arrancar la aplicaci\u00f3n el sistema se asegura de que el c\u00f3digo de la app no ha sido modificado desde la \u00faltima vez que fue instalada o actualizada.</p> <p>Para obtener un certificado, los desarrolladores deben registrase en el Apple Developer Program. Para publicar una app en el App Store, es necesario haberla firmado. De esta forma, toda app que nos instalemos en nuestros dispositivos ha sido desarrollada por una persona f\u00edsica u organizaci\u00f3n identificable.</p> <p>A diferencia de otras plataformas m\u00f3viles, iOS no permite que los usuarios instalen de p\u00e1ginas web apps no firmadas, potencialmente maliciosas. Tampoco permite ejecutar c\u00f3digo no fiable. </p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#cuenta-de-desarrollador-de-apple","title":"Cuenta de desarrollador de Apple","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distintos-programas-de-desarrollo","title":"Distintos programas de desarrollo","text":"<p>Apple define varios tipos de programas de desarrollo:</p> <ul> <li>Programa gratuito </li> <li>Programa de desarrollador de Apple (Apple Developer Program) - $99 al a\u00f1o</li> <li>Programa de desarrollador de empresa (Apple Developer Enterprise Program) - $299 al a\u00f1o</li> </ul> <p>Si s\u00f3lo queremos empezar a desarrollar y probar apps en nuestro dispositivo iOS basta con darse de alta de forma gratuita en el portal del desarrollador (member center) de Apple con un Apple ID.</p> <p>El programa de pago de desarrollador de Apple permite utilizar funcionalidades avanzadas, distribuir apps a dispositivos de prueba o subir nuestra app al App Store.</p> <p>El programa de desarrollador de empresa permite distribuir apps in-house, en los dispositivos del personal de la empresa, sin necesidad de usar el App Store.</p> <p>Adem\u00e1s de los anteriores programas, Apple ofrec\u00eda el denominado iOS Developer University Program orientado a la formaci\u00f3n en iOS en la universidad, que permit\u00eda acceder a funcionalidades intermedias entre el programa gratuito y el programa de pago, pero este programa fue descontinuado a partir del 25 de mayo de 2024. Este programa permit\u00eda utilizar servicios de Apple no disponibles en el programa gratuito y ejecutar apps en dispositivos registrados, no solo en el dispositivo de desarrollo. Como alternativa, tras la finalizaci\u00f3n de este programa, se proporcionar\u00e1n certificados de desarrollo que se podr\u00e1n importar para as\u00ed firmar manualmente las aplicaciones y poder tanto probarlas en dispositivos f\u00edsicos como acceder a caracter\u00edsticas de la plataforma que solo est\u00e1n disponibles para programas de pago (notificaciones push, iCloud, CloudKit, Game Center, etc).</p> <p>En concreto, las caracter\u00edsticas de cada uno de los programas se muestra en la siguiente tabla https://developer.apple.com/support/compare-memberships/:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#equipo-de-desarrollo","title":"Equipo de desarrollo","text":"<p>En los programas de pago de desarrollador de Apple es posible trabajar con un equipo de desarrolladores. No es necesario darse de alta como organizaci\u00f3n para componer un equipo.</p> <p>Cuando se da de alta un programa de desarrollo se crea un identificador de equipo \u00fanico (Team ID)  que compartir\u00e1n todos los desarrolladores del equipo. Se puede consultar el identificador de equipo en la opci\u00f3n Membership del portal del desarrollador.</p> <p></p> <p>Se pueden a\u00f1adir desarrolladores al equipo desde el App Store Connect, en la opci\u00f3n de Usuarios y Acceso.</p> <p></p> <p>Tambi\u00e9n es posible configurar los permisos de los desarrolladores del equipo para que puedan subir apps o probarlas como testers en Test Flight.</p> <p>Tambi\u00e9n se pueden configurar estas opciones en el programa universitario.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo","title":"Demo","text":"<p>Veremos una demostraci\u00f3n en la que accederemos al portal del desarrollador y al App Store Connect usando distintos perfiles:</p> <ul> <li>Perfil gratuito (domingo.gallardo.appledev2@gmail.com)</li> <li>Miembro de la cuenta de la universidad (domingo.gallardo.appledev1@gmail.com)</li> <li>Administrador de la cuenta de la universidad (domingo@dccia.ua.es)</li> <li>Perfil de pago (domingo@dccia.ua.es)</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#perfil-gratuito","title":"Perfil gratuito","text":"<p>Para darse de alta como desarrollador de Apple es necesario dar de alta un Apple ID y definir una autenticaci\u00f3n de doble factor. </p> <p>Con esta forma de autenticaci\u00f3n activada, cada vez que intentes acceder a tu cuenta desde un nuevo dispositivo tendr\u00e1s que introducir un c\u00f3digo de autorizaci\u00f3n que se env\u00eda a tus dispositivos autorizados en los que est\u00e1s logeado.</p> <p>Tambi\u00e9n es posible recibir un c\u00f3digo de autorizaci\u00f3n en un tel\u00e9fono m\u00f3vil que deber\u00e1s proporcionar en tu registro.</p> <p></p> <p>Una vez dados de alta como desarrolladores de Apple podremos acceder al portal del desarrollador.</p> <p></p> <p>Con esta cuenta gratuita podremos comenzar a desarrollar apps y probarlas en nuestro dispositivo de desarrollo. Pero este desarrollo estar\u00e1 limitado. No podremos distribuirlas a m\u00e1s dispositivos ni utilizar servicios avanzados de Apple.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#miembro-de-pago","title":"Miembro de pago","text":"<p>Si usamos una cuenta de pago, tenemos opciones adicionales:</p> <p></p> <p>Tambi\u00e9n tenemos acceso al portal de gesti\u00f3n de nuestras apps, el App Store Connect desde donde gestionar recursos relacionados con nuestro equipo de desarrollo y prueba, as\u00ed como preparar las apps para su distribuci\u00f3n en la App Store.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo","title":"Fin de la demo","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#certificados","title":"Certificados","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#codigo-firmado","title":"C\u00f3digo firmado","text":"<p>Para poder tanto ejecutar una app en un dispositivo f\u00edsico como distribuirla en el App Store es necesario firmar su c\u00f3digo digitalmente.</p> <p>La firma digital del c\u00f3digo (code signing) permite al sistema operativo identificar qui\u00e9n ha firmado la app y verificar que no se ha modificado desde el momento de su firma. El c\u00f3digo ejecutable est\u00e1 protegido por la firma y \u00e9sta se invalida si el c\u00f3digo cambia. Los recursos de la app como ficheros nib o im\u00e1genes no est\u00e1n firmados.</p> <p>En tiempo de ejecuci\u00f3n, el sistema iOS comprueba el c\u00f3digo firmado de todas las p\u00e1ginas ejecutables de memoria cuando se cargan, para asegurar que la app no ha sido modificada desde que fue instalada o actualizada por \u00faltima vez.</p> <p>Para poder firmar una app es necesario instalar un certificado proporcionado por Apple que proporciona la clave privada con la que se realiza la firma.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#identidad-de-firma","title":"Identidad de firma","text":"<p>Una identidad de firma (signing identity) consiste en una pareja de clave p\u00fablica y clave privada que proporciona Apple en el certificado de desarrollador.</p> <p>El certificado es creado por Xcode al a\u00f1adir la cuenta de usuario y se almacena en el llavero de inicio de sesi\u00f3n del Mac en el que se realiza el desarrollo (se puede consultar con la aplicaci\u00f3n Acceso a llaveros) y en el portal del desarrollador de Apple.</p> <p>La clave privada se usa para firmar la aplicaci\u00f3n. La clave p\u00fablica del certificado determina la identidad del desarrollador. La mantiene Apple en el centro de desarrollador y se guarda en los perfiles de aprovisionamiento del equipo de desarrollo.</p> <p>Se necesita tambi\u00e9n un certificado intermedio proporcionado por Apple. Cuando instalas Xcode este certificado intermedio se guarda en el llavero.</p> <p>Es muy importante conservar segura la clave privada, como si fuera una contrase\u00f1a de una cuenta. Debes mantener una contrase\u00f1a segura de tu pareja clave p\u00fablica-privada. Si se pierde la clave privada, tendr\u00e1s que crear una identidad completamente nueva para firmar el c\u00f3digo. O peor a\u00fan, si alguien se hace con tu clave privada puede hacerse pasar por ti e intentar distribuir una app con c\u00f3digo malicioso. Esto podr\u00eda hacer que Apple revocara tus credenciales de desarrollador.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#tipos-de-certificados","title":"Tipos de certificados","text":"<p>Existen varios tipos de certificados de desarrollo, de distribuci\u00f3n, para el servidor de notificaciones push, etc. El certificado de desarrollador permite ejecutar aplicaciones en un dispositivo. El de distribuci\u00f3n permite enviarla al App Store.</p> <p>Los certificados de desarrollo identifican a una persona del equipo. Los certificados de distribuci\u00f3n identifican al equipo y pueden ser compartidos por los miembros del equipo que tienen permiso para enviar apps al store.</p> <p>Todos los certificados son proporcionados por Apple.</p> <p>Para comprobar el tipo de certificado podemos consultar el portal del desarrollador, Xcode o Acceso a llaveros.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#gestion-de-los-certificados-en-xcode","title":"Gesti\u00f3n de los certificados en Xcode","text":"<p>Xcode mantiene nuestra identidad (Apple ID) y nuestros certificados. </p> <p>En el caso de pertenecer a m\u00e1s de un programa de desarrollo (por ejemplo al programa educativo de la UA y a nuestro programa personal) Xcode muestra los dos equipos y nos permite utilizar el que nos interese en cada momento.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-e-instalacion-de-certificados","title":"Creaci\u00f3n e instalaci\u00f3n de certificados","text":"<p>Es posible generar e instalar manualmente los certificados, pero es m\u00e1s sencillo dejar que sea Xcode quien los gestione.</p> <p>Al firmar una aplicaci\u00f3n por primera vez, Xcode se conecta a los servidores de Apple e instala autom\u00e1ticamente el certificado de firma.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#ejecucion-de-apps-en-dispositivos-reales","title":"Ejecuci\u00f3n de apps en dispositivos reales","text":"<p>Para la instalaci\u00f3n y ejecuci\u00f3n de una app iOS en un dispositivo f\u00edsico es necesario realizar una configuraci\u00f3n del target (binario que se instala en el dispositivo) que incluye m\u00faltiples procesos:</p> <ul> <li> <p>Firma digital del binario con un certificado del desarrollador   proporcionado por Apple (Signing Certificate).</p> </li> <li> <p>Instalaci\u00f3n de un perfil de aprovisionamiento (Provisioning   Profile) compatible con el bundle identifier de la app que determina,   entre otros: servicios de la plataforma Apple a los que la app puede   acceder (capabilities y entitlements) y dispositivos   concretos (IDs) autorizados en los que puede ejecutarse la app (lo   veremos m\u00e1s adelante).</p> </li> </ul> <p>Xcode facilita la realizaci\u00f3n de todos estos procesos. </p> <p></p> <p>El resultado de estos procesos es un fichero binario .ipa firmado digitalmente.</p> <p>La forma habitual de instalar una app en un dispositivo iOS es descarg\u00e1ndola del App Store. Pero tambi\u00e9n existen formas alternativas, para el caso de dispositivos de prueba o apps distribuidas internamente en una empresa (in-house). En estos casos es posible instalar las apps desde Test Flight, desde una web o con el programa de MacOS Apple Configurator.</p> <p>Resumiendo las distintas condiciones posibles, un dispositivo iOS puede ejecutar una app si:</p> <ol> <li>El dispositivo es un dispositivo de desarrollo inicializado por   Xcode.</li> <li>El dispositivo tiene instalado un perfil de aprovisionamiento   aprobado por el usuario, que contiene el UUID del propio dispositivo   y el certificado contiene la clave p\u00fablica del desarrollador que ha   firmado la app.</li> <li>Se trata de una versi\u00f3n beta de la app que se ha instalado con Test    Flight.</li> <li>El dispositivo tiene instalado un perfil de aprovisionamiento   aprobado por el usuario y la app est\u00e1 firmada con un certificado de   empresa proporcionado por Apple.</li> <li>Proviene del App Store y est\u00e1 firmada con un certificado de   distribuci\u00f3n en el App Store.</li> </ol>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo_1","title":"Demo","text":"<p>Vamos a demostrar c\u00f3mo firmar una app y c\u00f3mo ejecutarla en un dispositivo autorizado por Xcode, usando el perfil de desarrollador de la cuenta gratuita de Apple y despu\u00e9s usando el perfil de desarrollador del equipo de la Universidad de Alicante.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-de-la-identidad-de-firma","title":"Instalaci\u00f3n de la identidad de firma","text":"<p>Una vez creado el Apple ID, Xcode facilita el proceso de generaci\u00f3n de nuestra identidad de firma y de nuestro certificado de desarrollador.</p> <p>Escogemos Xcode &gt; Preferences y pinchamos en el signo + para a\u00f1adir Apple ID.</p> <p> </p> <p></p> <p>Si todo ha ido bien, Xcode mostrar\u00e1 la informaci\u00f3n de nuestro perfil gratuito. </p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-una-app","title":"Firma de una app","text":"<p>Para firmar una app con Xcode debemos seleccionar el proyecto completo, el target y, en el apartado General, rellenar el bundle ID de la app y seleccionar tu identidad de firma en la opci\u00f3n Signing &amp; Capabilities.</p> <p></p> <p>El bundle ID debe ser un identificador \u00fanico. Si utilizamos uno que ya se ha usado Xcode indicar\u00e1 un error. Podemos utilizar nuestro nombre de login, seguido de un punto y del nombre de la app.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#app-ejemplo-todo","title":"App ejemplo <code>ToDo</code>","text":"<p>Vamos a utilizar una app ya codificada para probar todos los conceptos de esta sesi\u00f3n. Se trata de una app muy sencilla, con la que podemos gestionar una lista de tareas por hacer.</p> <p></p> <p>Estando en el programa de desarrollo gratuito podemos probar la app en nuestro m\u00f3vil de desarrollo. Para ello es necesario firmar el c\u00f3digo compilado de la app con el certificado de desarrollador que acabamos de obtener.</p> <p>Al firmar la app, Xcode crear\u00e1 autom\u00e1ticamente el certificado de desarrollador.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#comprobacion-del-certificado","title":"Comprobaci\u00f3n del certificado","text":"<p>En la pantalla de Xcode &gt; Preferences... &gt; Accounts pulsamos Manage Certificates... para comprobar el certificado reci\u00e9n creado.</p> <p>Podemos gestionar los certificados (crear nuevos, exportar, importar, examinar) desde esta pantalla. Podemos encontrar m\u00e1s informaci\u00f3n en el manual de Xcode.</p> <p> </p> <p> </p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#comprobacion-de-la-identidad-de-firma-en-acceso-a-llaveros","title":"Comprobaci\u00f3n de la identidad de firma en Acceso a Llaveros","text":"<p>En la aplicaci\u00f3n Acceso a Llaveros podemos comprobar que el certificado se ha instalado junto con la clave privada en Mis certificados e Inicio de sesi\u00f3n.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#conexion-de-un-dispositivo-de-desarrollo-a-xcode","title":"Conexi\u00f3n de un dispositivo de desarrollo a Xcode","text":"<p>Una vez que se ha firmado la aplicaci\u00f3n es posible ejecutarla en un dispositivo de desarrollo conectado a Xcode. </p> <p>Comenzamos conectando el dispositivo iOS al ordenador. Se debe aceptar en el dispositivo un mensaje en el que se pide confirmaci\u00f3n para confiar en el ordenador.</p> <p>Despu\u00e9s, en Xcode seleccionamos Window &gt; Devices para comprobar que se ha conectado correctamente. En esa ventana se puede acceder al identificador UUID del dispositivo.</p> <p>Es posible activar la conexi\u00f3n inal\u00e1mbrica al dispositivo.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#prueba-en-un-dispositivo-real","title":"Prueba en un dispositivo real","text":"<p>Seleccionamos el dispositivo en el men\u00fa de ejecuci\u00f3n y ejecutamos para que la app se instale en el dispositivo.</p> <p>Es posible desplegar y ejecutar la aplicaci\u00f3n en el dispositivo de forma inal\u00e1mbrica.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#autorizacion-al-desarrollador-en-el-dispositivo","title":"Autorizaci\u00f3n al desarrollador en el dispositivo","text":"<p>Al ser un dispositivo de prueba gestionado autom\u00e1ticamente por Xcode, debemos autorizar al desarrollador antes de poder lanzarse la app.</p> <p></p> <p> </p> <p> </p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app","title":"Archivo y distribuci\u00f3n de la app","text":"<p>Seleccionando la opci\u00f3n de Xcode Product &gt; Archive se accede al panel de archivo y distribuci\u00f3n de la app </p> <p>Sin embargo, al estar registrado en el programa gratuito no es posible seleccionar ninguna forma de distribuci\u00f3n de la app.</p> <p></p> <p>Cuidado</p> <p>Para poder pulsar la opci\u00f3n Archive debe estar seleccionada la opci\u00f3n Generic iOS Device en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita. </p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-con-un-programa-de-desarrollador","title":"Firma con un programa de desarrollador","text":"<p>Si contamos con un programa de desarrollador de Apple, bien individual o de empresa,  podemos firmar indicando el bundle ID que queramos registrar en nuestra cuenta y seleccionando el <code>Team</code> correspondiente (por ejemplo,  <code>Universidad de Alicante</code>).</p> <p></p> <p></p> <p>Al seleccionar el equipo <code>Universidad de Alicante</code> Xcode selecciona nuestro certificado espec\u00edfico asociado al equipo de la UA y firma con \u00e9l la aplicaci\u00f3n.</p> <p>Firma manual: Al haber finalizado el programa iOS University Developer Program ya no es posible  registrar en Xcode una cuenta asociada al equipo de la UA, pero como alternativa podemos importar un certificado de desarrollo. Para ello, se proporcionar\u00e1 el certificado en un fichero de tipo <code>.p12</code>. Para importarlo, haremos doble click sobre el fichero, nos pedir\u00e1 la contrase\u00f1a suministrada, y tras introducirla el certificado quedar\u00e1 instalado en el sistema (podremos verlo en la aplicaci\u00f3n Acceso a llaveros). Una vez hecho esto, podremos eguir los pasos indicados a continuaci\u00f3n para importar perfiles de aprovisionamento que nos permitan desplegar la aplicaci\u00f3n en dispositivos f\u00edsicos y acceder a servicios de la plataforma de Apple.</p> <p>Podemos instalar cualquier perfil de aprovisionamiento creado en el equipo de desarrollo que sea compatible con el bundle ID. Para ello desmarcamos la opci\u00f3n <code>Automatically manage signing</code> y descargamos el perfil que nos interese. Un perfil de aprovisionamiento contiene un listado de capacidades que podemos activar en la app y un listado de dispositivos en los que podemos ejecutarla. M\u00e1s adelante explicaremos esto con m\u00e1s detalle.</p> <p></p> <p>En el siguiente ejemplo, se selecciona un perfil denominado <code>Gen\u00e9rico</code>:</p> <p></p> <p>Una vez instalado el perfil de aprovisionamiento, la configuraci\u00f3n de firma de la app queda como se muestra en la siguiente imagen:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#archivo-y-distribucion-de-la-app_1","title":"Archivo y distribuci\u00f3n de la app","text":"<p>Ahora ya podemos exportar la app y ejecutarla en cualquier dispositivo registrado en el perfil que acabamos de instalar. Para ello debemos seleccionar <code>Product &gt; Archive</code> y la opci\u00f3n <code>Development</code>.</p> <p></p> <p></p> <p></p> <p></p> <p>Se crea una carpeta que contiene el fichero <code>.ipa</code> que puede instalarse en cualquier dispositivo incluido en el perfil de aprovisionamiento (aunque no sea un dispositivo de desarrollo).</p> <p>Podemos instalar la app en un dispositivo conectando el dispositivo al Mac y usando el programa de Apple <code>Apple Configurator</code>.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo_1","title":"Fin de la demo","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#capacidades-de-las-apps","title":"Capacidades de las apps","text":"<p>Apple proporciona un conjunto de servicios para ser utilizados por las apps. Apple denomina a estos servicios como Capabilities. Para que una app pueda utilizar cualquiera de estas capabilities debe autorizarse su uso desde la cuenta de desarrollo o desde Xcode.</p> <p>Dependiendo del tipo de cuenta de desarrollo es posible utilizar unas capabilities y otras. Por ejemplo, podemos utilizar el servicio de mapas o el API de Health Kit con el programa gratuito, pero necesitamos el programa de la universidad para poder utilizar servicios iCloud o notificaciones push. Y existen capabilities avanzadas que s\u00f3lo pueden ser usadas con el programa de pago.</p> <p>Para una lista completa de las capacidades disponibles seg\u00fan el tipo de desarrollador se puede consultar la documentaci\u00f3n en Apple Developer &gt; Support &gt; Advanced App Capabilities</p> <p> </p> <p>Podemos explorar en Xcode el listado de capabilities que podemos a\u00f1adir a nuestra app, accediendo desde la pantalla de Signing &amp; Capabilities a la opci\u00f3n + Capability.</p> <p></p> <p>Con el programa gratuito podemos usar el siguiente listado de capabilities:</p> <p></p> <p>Con el programa de pago podemos acceder a todos los servicios proporcionados por Apple:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#bundle-identifier","title":"Bundle Identifier","text":"<p>Un bundle ID es una cadena que identifica de forma \u00fanica una app. Cuando definimos el bundle ID de un proyecto, Apple lo registra y no permite que ning\u00fan otro desarrollador utilice ese mismo ID. Si intentamos registrar un bundle ID que otro desarrollador ya ha usado Xcode nos informa de un error.</p> <p></p> <p>La cadena de bundle ID debe contener \u00fanicamente caracteres alfanum\u00e9ricos (A-Z,a-z,0-9), guiones (-), y puntos (.). Una forma de que no existan demasiadas colisiones en los bundle ID es usar un formato DNS-inverso con el nombre de la app y el dominio de nuestra organizaci\u00f3n. Por ejemplo, si el dominio de la organizaci\u00f3n es <code>Acme.com</code> y creamos una app llamada <code>Hola</code> podr\u00edamos usar como bundle ID de la app la cadena <code>com.Acme.Hola</code>. Tambi\u00e9n podr\u00edamos usar nuestro nombre y el nombre de la app (si nadie ha registrado una app con un nombre id\u00e9ntico al nuestro): <code>domingogallardo.Hola</code>.</p> <p>La forma de comprobar la disponibilidad del bundle ID es intentar firmar la app en la pantalla <code>Signing &amp; Capabilities</code> de Xcode. Al escribir el bundle ID y pulsar <code>Enter</code> Xcode intenta firmar la app y da un error si el bundle ID ya est\u00e1 cogido.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#uso-del-bundle-id","title":"Uso del Bundle ID","text":"<p>Ya que el bundle ID identifica una app de forma \u00fanica, \u00e9ste se utiliza en varias fases de su configuraci\u00f3n. En concreto, se usa en el proceso de aprovisionamiento de la app y en la configuraci\u00f3n de los permisos y capacidades a los que la app puede acceder. Cuando configuramos los permisos para que la app pueda utilizar determinados servicios debemos indicar a qu\u00e9 bundle IDs otorgamos esos permisos. Esto lo hacemos como el App ID.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#app-id","title":"App ID","text":"<p>El App ID es un patr\u00f3n de texto que da permiso a un \u00fanico bundle ID (identificador de la app) o a un conjunto de ellos. Un App ID define una lista de capacidades (whitelist) que permitimos usar a una app (explicit App ID) o varias apps (wildcard App ID).</p> <p>El App ID se puede crear de forma autom\u00e1tica desde Xcode o manualmente desde la propia cuenta de desarrollo. </p> <p></p> <p>Todos los App IDs creados se guardan en el portal del desarrollador. Los que crea Xcode de forma autom\u00e1tica tienen en su nombre el prefijo XC.</p> <p></p> <p>Por ejemplo, podr\u00edamos crear el App ID <code>es.ua.mudsdm.icloud.*</code> con la capability de acceso a iCloud. De esta forma, todos los bundles ID que tengan este prefijo podr\u00e1n acceder al servicio.</p> <p>Una vez creado, el App ID se instala en un perfil de aprovisionamiento que es el que finalmente hay que instalar en la app y permite que \u00e9sta acceda a los permisos otorgados. Adem\u00e1s, el perfil de aprovisionamiento tambi\u00e9n contendr\u00e1 los identificadores de los dispositivos de prueba en los que la app podr\u00e1 ejecutarse.</p> <p>En el caso de un desarrollador individual los permisos se gestionan autom\u00e1ticamente desde Xcode, que es quien se encarga de crear el App ID y otorgarle los permisos necesarios.</p> <p>La cadena del App ID contiene realmente dos partes separadas por un punto: el prefijo, que es el Team ID, y el sufijo que es la cadena de b\u00fasqueda del bundle ID propiamente dicha.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#gestion-de-las-capacidades-en-xcode","title":"Gesti\u00f3n de las capacidades en Xcode","text":"<p>Como se ha comentado anteriormente, podemos acceder en Xcode a las capabilities que queremos autorizar en la app que estamos desarrollando.</p> <p>Para ello debemos seleccionar el target y la opci\u00f3n Signing &amp; Capabilities y pulsar en + Capability.</p> <p></p> <p>Una vez seleccionadas las capacidades que necesitamos, Xcode busca en el portal del desarrollador alg\u00fan perfil de aprovisionamiento con un App ID que empareje el bundle ID y que satisfaga estas necesidades. Si no existe ninguno, crea el App ID y el perfil de aprovisionamiento de forma autom\u00e1tica. El App ID lo registra en la cuenta de desarrollo. S\u00f3lo lo puede hacer si somos administradores.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo_2","title":"Demo","text":"<p>Vamos a comprobar el uso de las capacidades (capabilities) en la app ToDo. Si pulsamos en <code>+ Capability</code> veremos que podemos a\u00f1adir un amplio conjunto de capacidades a la app. Son muchas m\u00e1s que en el perfil gratuito, por estar firmando la app con la cuenta de desarrollador del equipo de la UA.</p> <p>Pero para poder utilizar la capacidad, \u00e9sta debe estar autorizada por el perfil de aprovisionamiento. Y el perfil de aprovisionamiento <code>Gen\u00e9rico</code> no autoriza ninguna.</p> <p>Lo podemos comprobar seleccionando por ejemplo <code>Game Center</code>. Veremos el siguiente mensaje de error, que el perfil <code>Gen\u00e9rico</code> no autoriza la capacidad <code>Game Center</code>.</p> <p></p> <p>Podemos ver los perfiles en la web del desarrollador del equipo de la UA, y buscar un perfil que autorice esa capacidad.</p> <p></p> <p>Vemos que el perfil <code>Master Moviles ToDo</code> contiene las capacidades <code>Game Center</code>, <code>iCloud</code>, <code>In-App Purchase</code> y <code>Push Notifications</code>. Y que el App ID autoriza su uso al bundle ID <code>es.ua.mudsdm.ToDo</code>.</p> <p>Cambiamos el bundle ID de la app a <code>es.ua.mudsdm.ToDo</code>. Ese mismo identificador puede ser usado por distintos programadores, siempre que est\u00e9n en el mismo equipo. En este caso, en el equipo de la UA. </p> <p>Descargamos el perfil <code>Master Moviles ToDo</code>.</p> <p></p> <p>Y podemos comprobar que ahora ya no da ning\u00fan error el uso de la capacidad <code>Game Center</code>.</p> <p></p> <p>Al exportar la app tenemos que seleccionar manualmente el perfil correcto:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-de-la-demo_2","title":"Fin de la demo","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#despliegue-de-apps-en-dispositivos-de-prueba","title":"Despliegue de apps en dispositivos de prueba","text":"<p>Hemos visto que cuando estamos desarrollando una app podemos desplegarla en el dispositivo de desarrollo usando Xcode. </p> <p>Una vez terminada, y antes de publicarla en la App Store, debemos distribuirla en dispositivos de usuarios prueba para que realicen pruebas m\u00e1s extensas.</p> <p>Es posible hacerlo declarando los dispositivos de prueba en el portal del desarrollador y a\u00f1adi\u00e9ndolos al perfil de aprovisionamiento de la app. Vamos a ver estos conceptos.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#caracteristicas-del-dispositivo","title":"Caracter\u00edsticas del dispositivo","text":"<p>Cuando compilamos una app podemos especificar ciertas caracter\u00edsticas necesarias que debe tener el dispositivo en el que va a correr la app.</p> <p></p> <p>En el apartado Deployment Info de XCode, disponible en la pantalla Target &gt; General podemos definir:</p> <ul> <li>Tipo de dispositivo: iPhone, iPad o Mac (utilizando Mac Catalyst)</li> <li>Sistema operativo m\u00ednimo: versi\u00f3n de OS m\u00ednima necesaria de los   dispositivos en los que se va a instalar nuestra app.</li> <li>Caracter\u00edsticas de la interfaz de usuario y de la orientaci\u00f3n del dispositivo</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distribucion-de-apps","title":"Distribuci\u00f3n de apps","text":"<p>La forma de distribuir apps en la plataforma iOS es la App Store. Para enviar una app al App Store es necesario haberse registrado en el programa de pago de desarrollador de Apple. </p> <p>Apple proporciona un certificado de distribuci\u00f3n necesario para subir la app al App Store. De esta forma, todas las apps en el App Store han sido enviadas por una persona o una empresa conocida.</p> <p>Las apps enviadas son revisadas por Apple para asegurarse de que funcionan tal y como se describe y que no contiene bugs obvios ni otros problemas evidentes. Este proceso de curaci\u00f3n da a los clientes confianza en las apps que compran.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#aprovisionamiento-de-apps","title":"Aprovisionamiento de apps","text":"<p>Antes de distribuir la app en el App Store debemos haberla probada en dispositivos de prueba. </p> <p>Apple permite tambi\u00e9n distribuir apps de forma restringida, declarando los dispositivos en el portal del desarrollador e incorpor\u00e1ndolos en el perfil de aprovisionamiento de la app. Esto solo es posible si tenemos una cuenta de pago de desarrollador o si estamos en un equipo con una cuenta. En nuestro caso usaremos la cuenta del programa de desarrollo de la universidad.</p> <p>Una vez a\u00f1adido el perfil de aprovisionamiento a la app, podremos generar el archivo binario .ipa utilizando los m\u00e9todos de distribuci\u00f3n denominados Ad hoc y Development. Con ambos m\u00e9todos de distribuci\u00f3n podemos distribuir el app a aquellos dispositivos incluidos en la lista de dispositivos autorizados del perfil de aprovisionamiento. Con el segundo m\u00e9todo podemos adem\u00e1s distribuir la app a testers de nuestro equipo de desarrollo.</p> <p>El perfil de aprovisionamiento de la app tambi\u00e9n incluye las capacidades declaradas para que la app pueda acceder a servicios de la plataforma Apple (como almacenamiento iCloud, mapas, compras In-App o notificaciones push).</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#perfil-de-aprovisionamiento","title":"Perfil de aprovisionamiento","text":"<p>Un perfil de aprovisionamiento (provisioning profile) es un fichero que contiene una colecci\u00f3n de datos (claves p\u00fablicas de certificados, permisos, UUIDs de dispositivos autorizados, etc.) que conecta desarrolladores y dispositivos a un equipo de desarrollo autorizado y que permite que un dispositivo sea utilizado para pruebas.</p> <p>Un perfil de aprovisionamiento determina b\u00e1sicamente:</p> <ul> <li>Qu\u00e9 desarrolladores pueden compilar y distribuir un app.</li> <li>Qu\u00e9 servicios puede utilizar una app.</li> <li>En qu\u00e9 dispositivos se pueden ejecutar la app.</li> </ul> <p>Un perfil de aprovisionamiento contiene los siguientes elementos:</p> <p></p> <ul> <li>App ID: nombre del perfil, cadena de b\u00fasqueda y servicios   autorizados por el p\u00e9rfil.</li> <li>Certificados de desarrolladores del equipo.</li> <li>Dispositivos: Nombre e identificadores de dispositivos.</li> </ul> <p>F\u00edsicamente, los perfiles de aprovisionamiento son ficheros XML encriptados. Los que usa Xcode se guardan en el directorio <code>Library/MobileDevice/Provisioning Profiles</code>. Podemos acceder a este directorio desde el terminal o desde el Finder mostrando la carpeta <code>Biblioteca</code> con el men\u00fa <code>Ir + Alt &gt; Biblioteca</code> (el modificador <code>Alt</code> muestra las opciones ocultas).</p> <p>Si los borramos de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero).</p> <p>Es posible consultar su contenido desde el terminal con el comando:</p> <pre><code>security cms -D -i &lt;perfil&gt;.mobileprovision\n</code></pre> <p></p> <p>Tambi\u00e9n podemos visualizar su contenido con la vista previa del Finder:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#dispositivos-de-prueba-en-el-perfil-de-aprovisionamiento","title":"Dispositivos de prueba en el perfil de aprovisionamiento","text":"<p>El perfil de aprovisionamiento de una app se incluye en el binario de la app (fichero .ipa) y se instala autom\u00e1ticamente en el dispositivo cuando se copia la app.</p> <p>Para que la app se pueda ejecutar en el dispositivo, su UUID debe estar incluido en la lista de dispositivos autorizados del perfil. Adem\u00e1s se deben cumplir las siguientes condiciones:</p> <ul> <li>El bundle ID de la app empareja el App ID del perfil.</li> <li>Los permisos solicitados por la app est\u00e1n otorgados en el App ID del perfil.</li> <li>La app est\u00e1 firmada por un desarrollador cuya clave p\u00fablica est\u00e1 en la perfil de aprovisionamiento.</li> </ul> <p></p> <p>En combinaci\u00f3n con el bundle ID, el perfil de aprovisionamiento y los permisos (entitlements) se usan para asegurar que:</p> <ul> <li>La app ha sido compilada y firmada por nosotros o por un miembro de   confianza del equipo.</li> <li>Las apps firmadas por nosotros o por nuestro equipo se ejecutan s\u00f3lo en   dispositivos de desarrollo escogidos.</li> <li>Las apps se ejecutan \u00fanicamente en los dispositivos de prueba   que especifiquemos.</li> <li>Nuestra app no est\u00e1 usando servicios que no hemos a\u00f1adido al app.</li> <li>S\u00f3lo nosotros podemos enviar revisiones del app al store.</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-de-la-app-en-un-dispositivo-de-prueba","title":"Instalaci\u00f3n de la app en un dispositivo de prueba","text":"<p>Es posible instalar la app en el iPhone de prueba usando Xcode o Apple Configurator.</p> <p>La aplicaci\u00f3n Apple Configurator permite configurar dispositivos, hacer copias de seguridad, a\u00f1adir apps, etc.</p> <p></p> <p>La app se copia en el dispositivo junto con el perfil de aprovisionamiento (est\u00e1 incluido en el ipa). De esta forma, para ejecutar la app no es necesario autorizar el perfil del desarrollador.</p> <p></p> <p>Podemos instalar tambi\u00e9n el fichero ipa desde el panel de gesti\u00f3n de dispositivos de Xcode accesible desde la opci\u00f3n Window &gt; Devices.</p> <p>All\u00ed tambi\u00e9n podemos comprobar el perfil de aprovisionamiento reci\u00e9n instalado.</p> <p>Por \u00faltimo, es posible instalar la app en modo prueba a trav\u00e9s de Internet usando la herramienta oficial de Apple TestFlight, con la que se puede instalar la app tanto en dispositivos registrados en el perfil de aprovisionamiento como en dispositivos de usuarios de prueba desconocidos (hasta 10.000 usuarios de prueba). Para usar TestFlight es necesario ser un desarrollador de pago. </p> <p>Una alternativa gratuita son servicios como diawi o similares, que permiten distribuir la app tambi\u00e9n por Internet, pero solo a usuarios con el UDID incluido en el perfil de aprovisionamiento.</p> <p></p> <p>Tras subir el fichero ipa a la web se genera una URL y un c\u00f3digo QR desde la que se puede descargar la app en nuestro dispositivo. </p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#distribucion-y-ejecucion-de-apps-en-dispositivos-no-registrados","title":"Distribuci\u00f3n y ejecuci\u00f3n de apps en dispositivos no registrados","text":"<p>Existen dos tipos especiales de perfiles de aprovisionamiento que permiten que cualquier dispositivo (no solo aquellos que est\u00e1n registrados en el propio perfil) puedan ejecutar una app:</p> <ul> <li>El App Store Distribution Provisioning Profile que se utiliza para   poder subir la app al App Store de Apple.</li> <li>El In-house Distribution Provisioning Profile que se utiliza para   poder distribuir una app en la empresa y que debe tener un   certificado de empresa de Apple.</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#certificados-de-empresa","title":"Certificados de empresa","text":"<p>Los certificados de empresa de Apple han sido noticia recientemente debido a que Apple ha detectado malas pr\u00e1cticas en su uso por parte de Facebook y Google. Como castigo, Apple ha revocado los certificados durante un par de d\u00edas. Durante ese tiempo, las apps in-house de esas compa\u00f1\u00edas han dejado de funcionar. </p> <p>El mal uso de Facebook y Google de estos certificados ha puesto al descubierto la existencia de una gran cantidad de sitios que hacen un uso fraudulento de los certificados de empresa de Apple para distribuir apps no permitidas en el App Store (de juego o pornograf\u00eda) como si fueran apps in-house.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#demo_3","title":"Demo","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#resumen-del-flujo-de-trabajo","title":"Resumen del flujo de trabajo","text":"<p>En esta demo se ilustra todo el proceso desde el alta en un equipo de desarrollo hasta la firma, despliege y ejecuci\u00f3n de una aplicaci\u00f3n. Es importante destacar que para poder realizar todo este  proceso es necesario contar con un programa de desarrollo de pago de Apple. Como alternartiva, en  los ejercicios, se proporcionar\u00e1 un certificado de desarrollo que podremos importar en nuestro equipo, por lo que no ser\u00e1 necesario acceder al developer portal de Apple. </p> <p>Vamos a comprobar que es necesario firmar digitalmente la app para poder ejecutarla en un dispositivo y usar ciertos servicios como CloudKit, Game Center o compras In-App. Adem\u00e1s, veremos que la app puede ejecutarse en todos aquellos dispositivos que hayamos registrado y a\u00f1adido en el perfil de aprovisionamiento usado para firmar la app (adem\u00e1s de en el dispositivo de desarrollo autorizado por Xcode).</p> <p>Veremos que si seleccionamos la opci\u00f3n de firma autom\u00e1tica en Xcode, Xcode crear\u00e1 estos elementos de forma autom\u00e1tica. Tambi\u00e9n comprobaremos c\u00f3mo el administrador puede configurar App IDs y perfiles de aprovisionamiento en la web del equipo de desarrollo de Apple.</p> <p>Un resumen de los pasos que vamos a seguir en la demo:</p> <ol> <li>Nos damos de alta al equipo de la universidad.</li> <li>El administrador del equipo de la universidad crea un App ID con    ciertas capacidades y un perfil de aprovisionamiento con ese App    ID, los dispositivos de prueba y los desarrolladores del equipo.</li> <li>Compilamos la app, a\u00f1adimos las capacidades necesarias y la firmamos con la cuenta del equipo.</li> <li>Exportamos el fichero .ipa compilado de la app.</li> <li>Instalamos y ejecutamos la app en un dispositivo de prueba.</li> </ol>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#equipo-de-desarrollo-del-programa-de-universidad","title":"Equipo de desarrollo del programa de Universidad","text":"<p>La mayor\u00eda de opciones en el portal del desarrollador ser\u00e1n s\u00f3lo accesibles para consulta. Ser\u00e1 el administrador del equipo de la Universidad el que podr\u00e1 cambiarlas.</p> <p> </p> <p>Es necesario crear un nuevo certificado para el desarrollador, distinto del certificado individual. Servir\u00e1 para firmar aplicaciones desarrolladas en el equipo en el que se ha a\u00f1adido al desarrollador.</p> <p>Se puede hacer desde Xcode, seleccionando el equipo Universidad de Alicante y la opci\u00f3n Manage Certificates.... Ser\u00e1 un certificado de tipo iOS App Development.</p> <p> </p> <p></p> <p>Para confirmar que se ha creado el nuevo certificado, podemos entrar en el portal del desarrollador o en la aplicaci\u00f3n de Acceso a llaveros:</p> <p></p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#incorporacion-de-certificado-a-un-perfil-de-aprovisionamiento-administrador","title":"Incorporaci\u00f3n de certificado a un perfil de aprovisionamiento (administrador)","text":"<p>Para poder firmar y distribuir apps el certificado reci\u00e9n creado debe estar incluido en un perfil de aprovisionamiento compatible con la app que estamos desarrollando.</p> <p>Vamos a incorporar los nuevos certificados al perfil de aprovisionamiento gen\u00e9rico, con App ID comod\u00edn (<code>es.ua.*</code>) con el que se puede distribuir cualquier app que tenga un bundle id que comience por <code>es.ua</code>.</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-la-app-con-el-nuevo-certificado","title":"Firma de la app con el nuevo certificado","text":"<p>Para firmar la app con el nuevo certificado desmarcamos la opci\u00f3n para que Xcode gestione autom\u00e1ticamente la firma. De esta forma podremos gestionar manualmente qu\u00e9 perfil de aprovisionamiento es el que utilizamos.</p> <p>Seleccionamos el team Universidad de Alicante. Y escribimos como bundle id <code>es.ua.mudsdm.ToDo</code>.</p> <p>En el desplegable Provisioning Profile seleccionamos la opci\u00f3n Download Profile....</p> <p></p> <p>Aparece un listado con todos los perfiles de aprovisionamiento creados en nuestro equipo en el portal del desarrollador. Podemos examinarlos y seleccionar el m\u00e1s apropiado. Seleccionamos el denominado Gen\u00e9rico.</p> <p></p> <p>Vemos que se firma la aplicaci\u00f3n correctamente y que se a\u00f1ade el perfil de aprovisionamiento que hemos seleccionado. Aseg\u00farate que marcas la opci\u00f3n <code>All</code> para firmar con el perfil tanto la opci\u00f3n de <code>Debug</code> como la de <code>Release</code>.</p> <p></p> <p>La ventaja principal de firmar las apps de esta forma es que podremos distribuirlas a cualquier dispositivo incluido en el perfil.</p> <p>Prueba que es posible generar un fichero <code>.ipa</code> seleccionando la opci\u00f3n <code>Product &gt; Archive</code>. Para ello debe estar seleccionada la opci\u00f3n <code>Generic iOS Device</code> en el men\u00fa de ejecuci\u00f3n. Si est\u00e1 seleccionado un modelo concreto de iPhone la opci\u00f3n Archive se deshabilita.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#el-perfil-generico-no-tiene-configurado-ningun-servicio","title":"El perfil gen\u00e9rico no tiene configurado ning\u00fan servicio","text":"<p>Vamos ahora a intentar a\u00f1adir una capability. Por ejemplo, la de Game Center. Lo podemos hacer pulsando en el bot\u00f3n <code>+ Capability</code>,  seleccionando la opci\u00f3n Game Center. </p> <p>Intentamos compilar la app (Product &gt; Build) y aparecer\u00e1 el siguiente error:</p> <p></p> <p>El error se debe a que el perfil de aprovisionamiento seleccionado no soporta la capacidad Game Center.</p> <p>Es el administrador de la cuenta de la UA el que debe crear un perfil de aprovisionamiento para la app en el portal del desarrollador e incorporar en ese perfil el certificado del desarrollador.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#examinamos-los-perfiles-de-aprovisionamiento","title":"Examinamos los perfiles de aprovisionamiento","text":"<p>Podemos examinar los perfiles de aprovisionamiento desde el portal del desarrollador, desde Xcode y desde el terminal o el Finder (en el directorio <code>Library/MobileDevice/Provisioning Profiles</code>). Podemos acceder a la carpeta <code>Library</code> desde el Finder con el men\u00fa <code>Ir + Alt &gt; Biblioteca</code> (el modificador <code>Alt</code> muestra las opciones ocultas). Si borramos los perfiles de esa carpeta, autom\u00e1ticamente se borran de Xcode (esto es muy \u00fatil cuando tenemos alg\u00fan problema con los perfiles y queremos empezar de cero).</p> <p>En el portal del desarrollador tenemos que entrar en la opci\u00f3n Certificates, Identifiers and Profiles para entrar en la p\u00e1gina de gesti\u00f3n de los perfiles de aprovisionamiento.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#menu-de-opciones","title":"Men\u00fa de opciones","text":"<p>El portal del desarrollador contiene todos los perfiles de aprovisionamiento creados, junto con la informaci\u00f3n asociada.</p> <p></p> <ul> <li>Certificados: todos los certificados de los desarrolladores del   equipo.</li> <li>Identificadores: todos los App IDs aprobados, con las   caracter\u00edsticas aprobadas en cada uno de ellos.</li> <li>Dispositivos: todos los dispositivos aprobados para probar las   apps</li> </ul>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-de-un-app-id-desde-el-portal-del-desarrollador-administrador","title":"Creaci\u00f3n de un App ID desde el portal del desarrollador (administrador)","text":"<p>S\u00f3lo se puede hacer con el rol administrador. Se pulsa <code>+</code> en la cabecera Identifiers. Se selecciona la opci\u00f3n Register a New Identifier y se escoge la opci\u00f3n App IDs. Vemos que hay otros posibles identificadores que podemos crear.</p> <p></p> <p>Se define la descripci\u00f3n del App ID y el prefijo de App ID (que debe emparejar con el bundle id de la aplicaci\u00f3n). Se escoge la opci\u00f3n Explicit para indicar que no se va a usar un prefijo con comod\u00edn. La app deber\u00e1 tener exactamente el bundle id <code>es.ua.mudsdm.ToDo</code> para poder aplicarse el App ID.</p> <p></p> <p>Se puede comprueba que la capability Game Center ya est\u00e1 seleccionada por defecto.</p> <p></p> <p>Confirmamos y el App Id queda registrado en el portal del desarrollador:</p> <p></p> <p>Una vez creado el App Id en el que definimos las capacidades del app, podemos pasar a a\u00f1adir los dispositivos en los que vamos a permitir probar el app. Y, por \u00faltimo, crearemos un perfil de aprovisionamiento que contenga el App Id y los dispositivos y que se descargar\u00e1 la app.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#dispositivos-administrador","title":"Dispositivos (administrador)","text":"<p>Para a\u00f1adir un dispositivo al portal del desarrollador hay que seleccionar la opci\u00f3n correspondientes (Devices) y a\u00f1adir su UDID, Unique Device Identifier.</p> <p></p> <p></p> <p>El UDID es una cadena de 40 caracteres de s\u00edmbolos alfanum\u00e9ricos (a-z y 0-9) \u00fanica de cada dispositivo. Se puede obtener desde Xcode en la pantalla de Dispositivos (Window &gt; Devices).</p> <p>Se pueden registrar en el portal del desarrollador hasta 200 UDIDs para probar aplicaciones en desarrollo.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#creacion-de-perfiles-de-aprovisionamento-administrador","title":"Creaci\u00f3n de perfiles de aprovisionamento (administrador)","text":"<p>Una vez creado el App ID con los permisos necesarios, a\u00f1adidos los certificados de los desarrolladores del equipo y a\u00f1adidos los dispositivos es posible crear un nuevo perfil de aprovisionamiento.</p> <p>Se puede hacer desde el portal del desarrollador y tambi\u00e9n desde Xcode. Es m\u00e1s claro ver el proceso desde portal del desarrollador, ya que Xcode mezcla el proceso de creaci\u00f3n del perfil con el de dar autorizaciones (entitlements) a la propia aplicaci\u00f3n.</p> <p>Para crear un nuevo perfil de aprovisionamiento desde el portal del desarrollador, se selecciona la opci\u00f3n iOS App Development.</p> <p></p> <p>Se selecciona el App ID que queremos incluir en el perfil:</p> <p></p> <p>Se seleccionan los certificados de los desarrolladores a los que van a utilizar este perfil para compilar apps en Xcode:</p> <p></p> <p>Se seleccionan los dispositivos en los que vamos a poder probar la app:</p> <p></p> <p>Por \u00faltimo se da un nombre al perfil de aprovisionamiento:</p> <p> </p> <p>Y aparece una pantalla con el resumen del perfil generado. Se puede descargar en el ordenador para despu\u00e9s a\u00f1adirlo manualmente a la app usando Xcode. Tambi\u00e9n se puede descargar directamente desde Xcode.</p> <p> </p> <p>Listado de los perfiles de aprovisionamiento creados en el portal de desarrolladores:</p> <p></p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#firma-de-la-app-todo-con-el-perfil-de-aprovisionamiento-creado","title":"Firma de la app ToDo con el perfil de aprovisionamiento creado","text":"<p>Una vez creado el perfil de aprovisionamiento ya es posible instalarlo en la app. </p> <p>Igual que antes nos aseguramos de que tenemos activa la opci\u00f3n manual y volvemos a seleccionar Download Profile.... Veremos ahora que ha aparecido el perfil que el administrador ha a\u00f1adido. Lo seleccionamos:</p> <p> </p> <p>Y ahora ya podemos ver que desparece el error anterior porque el nuevo perfil ya tiene la capacidad Game Center.</p> <p> </p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#exportar-la-app","title":"Exportar la app","text":"<p>Seleccionando en Xcode la opci\u00f3n Product &gt; Archive (hay que asegurarse de que el tipo de dispositivo seleccionado es Generic iOS Device) ahora ya funcionar\u00e1 la opci\u00f3n Distribute App.</p> <p></p> <p>Las opciones App Store y Ad Hoc no funcionan por no tener una cuenta de universidad permisos para subir apps al App Store. Se puede hacer con una cuenta de pago. En la opci\u00f3n Ad Hoc es posible definir una URL privada para descargar la app y probarla.</p> <p>La \u00fanica opci\u00f3n de exportaci\u00f3n que funciona es Development, que permite distribuir la app a cualquier dispositivo incluido en el perfil de aprovisionamiento.</p> <p></p> <p>La opci\u00f3n de <code>App Thining</code> permite generar distintos ficheros ipa adaptados a cada tipo de dispositivo, lo que minimiza el tama\u00f1o del fichero. Si no se selecciona, se genera un \u00fanico fichero ipa que puede ejecutarse en cualquier dispositivo.</p> <p>Seleccionamos el perfil de aprovisionamiento que acabamos de crear <code>Master Moviles ToDo</code>.</p> <p></p> <p>Y, por \u00faltimo, confirmamos la opci\u00f3n de exportar:</p> <p></p> <p>Tarda un rato en generar el fichero ipa (iOS App file).</p> <p>Se genera una carpeta con un fichero <code>ToDo.ipa</code>, que es un binario que se puede instalar s\u00f3lo en dispositivos autorizados en el perfil de aprovisionamiento.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#instalacion-y-ejecucion-de-la-app","title":"Instalaci\u00f3n y ejecuci\u00f3n de la app","text":"<p>Probamos a instalar la app en un dispositivo autorizado (su UUID est\u00e1 incluido en el perfil de aprovisionamiento) usando Apple Configurator.</p> <p></p> <p>Para poder ejecutar la app en el dispositivo debemos activar el modo de desarrollador.</p>"},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#fin-demo","title":"Fin demo","text":""},{"location":"teoria/firma-aprovisionamiento/firma-aprovisionamiento.html#bibliografia","title":"Bibliograf\u00eda","text":"<ul> <li>Developer Support</li> <li>Developer Account Help</li> <li>Code Signing Help</li> <li>Xcode Documentation</li> <li>Preparing your app for distribution</li> <li>Distribute your app to registered devices</li> <li>App Store Connect Help</li> <li>Test Flight</li> </ul>"},{"location":"teoria/icloud/icloud.html","title":"4. iCloud y CloudKit","text":""},{"location":"teoria/icloud/icloud.html#icloud-y-cloudkit","title":"iCloud y CloudKit","text":""},{"location":"teoria/icloud/icloud.html#icloud","title":"iCloud","text":"<p>iCloud es un servicio de Apple que permite a un usuario acceder a su contenido personal (datos, documentos) en todos sus dispositivos utilizando su Apple ID.</p> <p>iCloud consigue esto combinando almacenamiento en la nube y APIs dedicadas integradas en el sistema operativo.</p> <p>Apple proporciona la infraestructura de servidores, de transmisi\u00f3n de datos y de cuentas de usuario, facilitando el trabajo a los desarrolladores que no necesitan crear sus propios servicios ni recurrir a soluciones de terceros.</p>"},{"location":"teoria/icloud/icloud.html#filosofia-de-icloud-para-el-usuario-de-ios","title":"Filosof\u00eda de iCloud para el usuario de iOS","text":"<p>Un escenario frecuente es que un usuario tenga una app instalada en m\u00e1s de un dispositivo (un iPhone y un iPad, por ejemplo).  Por ejemplo es muy com\u00fan usar la app de fotos, la del calendario, o las notas en cualquier dispositivo.</p> <p>En este escenario, la idea principal de iCloud es que el usuario pueda pasar de un dispositivo a otro y seguir trabajando con el mismo estado de la app tal y como la dej\u00f3 en el dispositivo anterior.</p> <p>Para el usuario, los cambios aparecen autom\u00e1ticamente en todos los dispositivos conectados a la cuenta iCloud.</p>"},{"location":"teoria/icloud/icloud.html#cuenta-icloud","title":"Cuenta iCloud","text":"<p>Todo usuario de Apple puede activar una cuenta de iCloud usando su Apple ID. Casi todos los usuarios de dispositivos Apple tienen activada esta cuenta.</p> <p>Permite mantener el estado en aplicaciones ejecut\u00e1ndose en distintos dispositivos asociados al mismo Apple ID: Recordatorios, Notas, etc.</p> <p>El sistema operativo encripta todos los datos antes de transmitirlos a los servidores de iCloud, los cuales almacenan los datos tambi\u00e9n en formato encriptado. Se utilizan tokens para la autenticaci\u00f3n. </p> <p>De forma gratuita Apple proporciona 5Gb de espacio en la cuenta de iCloud.</p> <p>Nota</p> <p>La cuenta de iCloud puede activarse desde el simulador. Si es la primera vez que usas iCloud desde el simulador debes logearte con tu Apple Id en icloud.com y aceptar los t\u00e9rminos.</p>"},{"location":"teoria/icloud/icloud.html#distintas-apis","title":"Distintas APIs","text":"<p>Bajo el nombre gen\u00e9rico de iCloud, existen distintas APIs que Apple ha ido proporcionando a los desarrolladores para gestionar datos asociados a la cuenta de usuario:</p> <ul> <li>Almacenamiento clave-valor en iCloud: para mantener el estado de   la aplicaci\u00f3n (puntuaci\u00f3n de un juego, \u00faltima p\u00e1gina le\u00edda, etc.).</li> <li>Documentos en iCloud: para gestionar documentos en la nube y   mantenerlos sincronizados entre iPhone/iPad/Mac.</li> <li>iCloud con Core Data: para mantener de forma autom\u00e1tica en   iCloud una copia de todos los datos de la app gestionados con Core   Data. Versi\u00f3n inicial con muchos problemas, muy mejorado en las   \u00faltimas versiones.</li> <li>CloudKit: nueva tecnolog\u00eda a partir de iOS 8   que permite mayor flexibilidad y control. Basado en la gesti\u00f3n en la   nube de registros con diccionarios clave-valor, con un enfoque muy   similar a las tecnolog\u00edas NoSQL.<ul> <li>Se trata de un API de peticiones a los servidores en la nube,   que no mantiene un estado local. Es conveniente usarla en combinaci\u00f3n   con Core Data, si queremos hacer persistentes en local los datos   existentes en la nube.</li> <li>Basada en peticiones y respuestas as\u00edncronas.</li> </ul> </li> </ul> <p>Vamos a ver en esta sesi\u00f3n el almacenamiento clave-valor y CloudKit, que son las APIs m\u00e1s usadas.</p>"},{"location":"teoria/icloud/icloud.html#preparacion-de-aprovisionamiento-y-permisos-para-icloud","title":"Preparaci\u00f3n de aprovisionamiento y permisos para iCloud","text":"<p>Para desarrollar con iCloud es necesario estar registrado como desarrollador en el programa de desarrollo de Apple. Tambi\u00e9n puedes hacerlo con tu Apple ID registrado en el equipo de la UA.</p> <p>Para usar los servicios de iCloud es necesario crear un perfil de aprovisionamiento con un App Id concreto, a\u00f1adir el servicio de iCloud y activar el permiso (capabilities) en la app con XCode.</p> <p>Si est\u00e1s registrado en el equipo de desarrollo con un rol de administrador (o tienes una cuenta de pago en la que tienes todos los permisos de tu equipo), se puede hacer todo autom\u00e1ticamente desde Xcode.</p>"},{"location":"teoria/icloud/icloud.html#creacion-del-app-id","title":"Creaci\u00f3n del App ID","text":"<p>Para trabajar con iCloud clave-valor puedes utilizar el perfil de aprovisionamiento <code>SPM iCloud</code> creado en el developer portal. El bundle ID de la app debe ser <code>es.ua.mudsdm.iCloud</code>.</p> <p>Tambi\u00e9n hemos actualizado el perfil <code>SPM ToDo</code> para incluir los permisos de uso de iCloud y CloudKit.</p> <p>Se debe crear el App ID que otorgue la capacidad de acceso a iCloud.</p> <p>Hemos creado el permiso (App ID) <code>Master Moviles iCloud</code> con el bundle name <code>es.ua.mudsdm.iCloud</code> que incluye la capacidad de iCloud.  </p> <p> </p> <p>Aparece un bot\u00f3n junto al permiso de iCloud porque requiere una configuraci\u00f3n posterior relacionada con CloudKit (lo veremos m\u00e1s adelante). Pero es suficiente para trabajar con iCloud clave-valor.</p>"},{"location":"teoria/icloud/icloud.html#icloud-clave-valor","title":"iCloud clave-valor","text":""},{"location":"teoria/icloud/icloud.html#api-de-almacenamiento-clave-valor","title":"API de almacenamiento clave-valor","text":"<p>Permite guardar y recuperar en iCloud claves y valores desde los dispositivos en los que el usuario est\u00e1 registrado con su Apple Id.</p> <p>Para gestionar estos valores debemos usar la clase NSUbiquitousKeyValueStore.</p> <p>Puedes almacenar <code>String</code>s, valores escalares como <code>BOOL</code> o <code>Double</code>, diccionarios y tambi\u00e9n objetos de cualquiera de los siguientes tipos: <code>NSNumber</code>, <code>NSString</code>, <code>NSDate</code>, <code>NSData</code>, <code>NSArray</code>, or <code>NSDictionary</code>.</p> <p>El espacio de almacenamiento total, para un usuario dado y una app, es de 1 MB y un m\u00e1ximo de 1024 claves.</p> <p>Para obtener el objeto compartido iCloudKeyValueStore:</p> <pre><code>let iCloudStore = NSUbiquitousKeyValueStore.default\n</code></pre>"},{"location":"teoria/icloud/icloud.html#metodo-synchronize","title":"M\u00e9todo <code>synchronize</code>","text":"<pre><code>func synchronize() -&gt; Bool\n</code></pre> <p>Devuelve <code>true</code> si las claves y valores en memoria y en disco est\u00e1n sincronizados o <code>false</code> si ha sucedido alg\u00fan error. Por ejemplo, devuelve <code>false</code> si la app no se ha compilado con las peticiones adecuadas de entitlement o si el usuario no est\u00e1 logeado e iCloud.</p> <p>Los cambios al almac\u00e9n de claves-valor se salvan en memoria. El sistema sincroniza autom\u00e1ticamente estos datos con la cach\u00e9 del disco en los momentos apropiados. Por ejemplo, cuando el app pasa a segundo plano o cuando se reciben cambios de iCloud.</p> <p>Este m\u00e9todo no fuerza la subida a iCloud de los nuevos valores y claves, sino que hace saber a iCloud que los valores est\u00e1n listos para ser subidos. El sistema controla cu\u00e1ndo subir los datos.</p> <p>No es obligatorio su uso, pero es recomendable cuando estamos trabajando con el simulador para asegurarnos de que el almac\u00e9n de claves-valor se guarda.</p> <p>Se recomiendo tambi\u00e9n hacerlo despu\u00e9s de lanzar la app o cuando vuelve al primer plano.</p>"},{"location":"teoria/icloud/icloud.html#ejemplo-de-uso-de-synchronize-al-lanzar-la-app","title":"Ejemplo de uso de <code>synchronize</code> al lanzar la app","text":"<pre><code>@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n    let store = NSUbiquitousKeyValueStore.default\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n        // Override point for customization after application launch.\n        if (store.synchronize()) {\n            print(\"Sincronizaci\u00f3n OK\")\n        } else {\n            print(\"Problemas en la sincronizaci\u00f3n\")\n        }\n    }\n\n    ...\n\n}\n</code></pre>"},{"location":"teoria/icloud/icloud.html#guardar-valores-en-el-almacen-de-claves-valor","title":"Guardar valores en el almac\u00e9n de claves-valor","text":"<p>Para actualizar los valores hay que usar los m\u00e9todos set. El primer par\u00e1metro es el valor a guardar y el segundo la clave:</p> <ul> <li><code>set(Bool, forKey: String)</code></li> <li><code>set(Double, forKey: String)</code></li> <li><code>set(Int64, forKey: String)</code></li> <li><code>set([Any]?, forKey: String)</code></li> <li>...</li> </ul> <p>Por ejemplo, <code>set(Int64, forKey: String)</code> actualiza en el almac\u00e9n el valor long long (<code>Int64</code>) asoci\u00e1ndolo a una clave especificada:</p> <pre><code>store.set(100, forKey: \"puntuacion\")\n</code></pre>"},{"location":"teoria/icloud/icloud.html#obtencion-de-valores-del-almacen-de-claves-valor","title":"Obtenci\u00f3n de valores del almac\u00e9n de claves-valor","text":"<p>Funciones que obtienen los distintos tipos de datos a partir de una clave (una cadena):</p> <ul> <li><code>array(forKey: String) -&gt; [Any]?</code></li> <li><code>bool(forKey: String) -&gt; Bool</code></li> <li><code>dictionary(forKey: String) -&gt; [String : Any]?</code></li> <li><code>string(forKey: String) -&gt; String?</code></li> <li><code>longLong(forKey: String) -&gt; Int64</code></li> <li>...</li> </ul> <p><code>forKey</code> es el String que es la clave en el almac\u00e9n de  claves-valor.</p> <p>Devuelve el valor asociado a la clave o <code>nil</code> si la clave no existe (0 en el caso de los m\u00e9todos que devuelven un valor num\u00e9rico).</p> <p>Por ejemplo, <code>longlong(forKey: String)</code>  devuelve el valor <code>Int64</code> asociado a una clave especificada:</p> <pre><code>let puntuacion = Int(store.longLong(forKey:\"puntuacion\"))\n</code></pre> <p>En la aplicaci\u00f3n ejemplo que veremos despu\u00e9s en la demostraci\u00f3n tenemos el siguiente c\u00f3digo que sincroniza el valor actual de la interfaz de usuario (una etiqueta con un valor) con el valor del almac\u00e9n de iCloud.</p> <pre><code>class ViewController: UIViewController {\n\n    let store = NSUbiquitousKeyValueStore.default\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n        let valoriCloud = Int(store.longLong(forKey: \"valor\"))\n        print(\"Valor cargado de iCloud: \\(valoriCloud)\")\n        self.muestra(valor: valoriCloud)\n    }\n\n    @IBAction func pulsadoStepper(_ sender: UIStepper) {\n        let valorPulsado: Int = Int(sender.value)\n        store.set(valorPulsado, forKey: \"valor\")\n        store.synchronize()\n        self.muestra(valor: valorPulsado)\n    }\n</code></pre>"},{"location":"teoria/icloud/icloud.html#definicion-de-un-observador-de-cambios","title":"Definici\u00f3n de un observador de cambios","text":"<p>Adem\u00e1s de almacenar los valores podemos recibir notificaciones (<code>NSNotification</code> gestionadas por el <code>NotificationCenter</code>) de cambio de los valores en otros dispositivos conectados a iCloud.</p> <p>En el lanzamiento del app hay que registrarse para la notificaci\u00f3n <code>NSUbiquitousKeyValueStoreDidChangeExternallyNotification</code>.</p> <p>La notificaci\u00f3n se env\u00eda cuando el valor de una o m\u00e1s claves han cambiado debido a datos que han llegado desde iCloud. La notificaci\u00f3n no se env\u00eda cuando la propia app ha cambiado los valores.</p> <p>El diccionario atributo <code>userInfo</code> de la notificaci\u00f3n contiene la raz\u00f3n de la notificaci\u00f3n, as\u00ed como una lista de los valores cambiados.</p> <p>El objeto en la notificaci\u00f3n es el <code>NSUbiquitousKeyValueStore</code> cuyo contenido ha cambiado.</p> <p>Por ejemplo, en el siguiente c\u00f3digo se registra como observador un m\u00e9todo de la propia clase <code>AppDelegate</code>:</p> <pre><code>@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n    let store = NSUbiquitousKeyValueStore.default\n\n    func application(_ application: UIApplication, \n                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {\n        // Override point for customization after application launch.\n        if (store.synchronize()) {\n            print(\"Sincronizaci\u00f3n OK\")\n        } else {\n            print(\"Problemas en la sincronizaci\u00f3n\")\n        }\n        NotificationCenter.default.addObserver(\n            self,\n            selector: #selector(muestraValoriCloud(notification:)),\n            name: NSUbiquitousKeyValueStore.didChangeExternallyNotification,\n            object: nil)\n        return true\n    }\n\n    @objc func muestraValoriCloud(notification: Notification){\n        let valoriCloud = Int(store.longLong(forKey: \"valor\"))\n        print(\"Recibida notificaci\u00f3n del sistema con el valor: \\(valoriCloud)\")\n        // Actualizamos el valor en el controller\n        DispatchQueue.main.async {\n            let application = UIApplication.shared\n            if let controller = application.windows[0].rootViewController {\n                let miController: ViewController = controller as! ViewController\n                miController.muestra(valor: valoriCloud)\n            }\n        }\n    }\n</code></pre>"},{"location":"teoria/icloud/icloud.html#demo","title":"Demo","text":"<ul> <li>Descargamos la app <code>iCloudKeyValue</code> desde este   enlace,   comentamos su funcionamiento y a\u00f1adimos el c\u00f3digo para incorporar iCloud clave valor:<ul> <li>Primero para que vaya grabando en iCloud el \u00faltimo n\u00famero   pulsado, y para que se obtenga cuando arranca la app. Lo   probamos primero en el simulador y despu\u00e9s en el dispositivo f\u00edsico.</li> <li>Nos logeamos con nuestra cuenta de iCloud en el simulador y   probamos si se comparte la informaci\u00f3n con el dispositivo f\u00edsico.</li> <li>Nos logeamos despu\u00e9s en otro dispositivo f\u00edsico (un iPad) y   probamos si se comparte la informaci\u00f3n entre los dos   dispositivos f\u00edsicos.</li> <li>Por \u00faltimo a\u00f1adimos el c\u00f3digo para que se actualice la   informaci\u00f3n entre dos dispositivos con una notificaci\u00f3n del   sistema. </li> </ul> </li> </ul>"},{"location":"teoria/icloud/icloud.html#cloudkit","title":"CloudKit","text":""},{"location":"teoria/icloud/icloud.html#introduccion-a-cloudkit","title":"Introducci\u00f3n a CloudKit","text":"<p>El origen de CloudKit es un proyecto interno de Apple en el que se basan muchas de sus APIs de persistencia. Su uso se ofrece a les desarrolladores en la WWDC de 2014, para apps a partir de iOS 8.</p> <p>Permite gestionar datos remotos ubicados en los servidores de iCloud propios de Apple.</p> <p>En los datos propios de la aplicaci\u00f3n (datos privados del usuario) el almacenamiento se imputa a las cuentas iCloud de los usuarios.</p> <p>Existe la posibilidad de datos p\u00fablicos, en un almacenamiento gestionado por el desarrollador (gratuito hasta una capacidad y de pago a partir de ella).</p> <p>Permite datos estructurados y datos bulk.</p> <p>CloudKit proporciona una base de datos NoSQL en la nube, mediante la que las aplicaciones pueden guardar, consultar y realizar b\u00fasquedas de registros. </p>"},{"location":"teoria/icloud/icloud.html#tecnologia-de-transporte","title":"Tecnolog\u00eda de transporte","text":"<p>CloudKit no proporciona ninguna forma de almacenar datos localmente.</p> <p>Los datos obtenidos se almacenan en la aplicaci\u00f3n. Si queremos hacerlos persistentes de forma local (para que est\u00e9n disponibles sin conexi\u00f3n) podemos utilizar otra tecnolog\u00eda como Core Data.</p> <p>Es un servicio para mover datos a y desde la nube iCloud y no est\u00e1 pensado para reemplazar los modelos de datos ya existentes en tu app (CoreData).</p> <p>El objetivo del framework es complementar estos modelos con una forma de empaquetar los datos para la nube y recibir actualizaciones posteriores sobre esos datos.</p> <p>Con CloudKit, tu eres el responsable de mover los datos desde tu app a iCloud y desde iCloud a la app. Aunque CloudKit proporciona facilidades para mantenerte informado cuando sucede un cambio, tu debes obtener esos cambios expl\u00edcitamente.</p> <p>Debido a que eres el responsable de obtener y salvar los datos, debes de asegurarte de que los datos se obtienen en el momento oportuno y en el orden correcto, y de manejar los errores que se producen.</p>"},{"location":"teoria/icloud/icloud.html#elementos-de-cloudkit","title":"Elementos de CloudKit","text":"<ul> <li>Contenedores</li> <li>Bases de datos</li> <li>Registros</li> <li>Zonas de registros</li> <li>Identificadores</li> <li>Referencias </li> </ul>"},{"location":"teoria/icloud/icloud.html#contenedores","title":"Contenedores","text":"<p>M\u00faltiples apps y usuarios tienen acceso a iCloud, pero los datos se encuentran segregados y encapsulados en particiones llamadas <code>contenedores</code>. En general, un contenedor va a contener todos los datos p\u00fablicos y de usuarios de una aplicaci\u00f3n. Tambi\u00e9n es posible que m\u00e1s de una app del mismo desarrollador compartan un \u00fanico contenedor.</p> <p>Los datos se encuentran almacenados en un contenedor. Los contenedores de tus apps no pueden ser usados por apps de otro desarrollador.</p> <p>Es posible compartir un contenedor entre varias apps, siempre que hayan sido desarrolladas por el mismo desarrollador.</p> <p>Cada contenedor tiene un nombre \u00fanico que por defecto est\u00e1 asociado al bundle id de la app. El nombre es <code>iCloud.&lt;bundleId&gt;</code>.</p> <p>Los contenedores no pueden borrarse. En el portal de desarrolladores de la UA hemos acumulado muchos nombres antiguos de contenedores que ya no se usan.</p>"},{"location":"teoria/icloud/icloud.html#clase-ckcontainer","title":"Clase CKContainer","text":"<p>La clase con la que trabajar para gestionar el contenedor es   CKContainer</p> <p>La debemos usar para:</p> <ul> <li>Obtener las bases de datos p\u00fablicas y privadas</li> <li>Obtener el identificador del contenedor</li> <li>Determinar el estado del acceso de la cuenta iCloud del usuario</li> <li>Solicitar y determinar permisos de la app</li> <li>Ejecutar operaciones sobre el contenedor</li> <li>Descubrir registros de usuarios </li> </ul> <p>En CloudKit todas las operaciones son as\u00edncronas: se pasa el c\u00f3digo de callback al que se llamar\u00e1 cuando la petici\u00f3n devuelva la respuesta.</p>"},{"location":"teoria/icloud/icloud.html#datos-publicos-y-privados","title":"Datos p\u00fablicos y privados","text":"<p>Se pueden guardar datos de forma p\u00fablica y privada, dependiendo de si se guardan en la base de datos p\u00fablica o en la privada.</p> <p>Los datos p\u00fablicos son accesibles a todos los usuarios de la app, aunque el usuario no se haya identificado con su cuenta de iCloud.</p> <p>Los datos privados son s\u00f3lo visibles por el usuario actual logeado en iCloud.</p> <p>Para salvar datos en la base de datos p\u00fablica es necesario que el usuario est\u00e9 identificado, porque siempre se guarda el usuario propietario del registro.</p>"},{"location":"teoria/icloud/icloud.html#bases-de-datos","title":"Bases de datos","text":"<p>Las bases de datos son instancias de la clase <code>CKDatabase</code></p> <p>Cada app tiene acceso a dos bases de datos:</p> <ul> <li>Base de datos p\u00fablica</li> <li>Base de datos privada</li> </ul> <p>Se obtienen a trav\u00e9s del <code>CKContainer</code>:</p> <pre><code>let container = CKContainer.default()\nlet privateDB = container.privateCloudDatabase\nlet publicDB = container.publicCloudDatabase\n</code></pre> <p></p>"},{"location":"teoria/icloud/icloud.html#cloudkit-console","title":"CloudKit Console","text":"<p>El CloudKit Console es una interfaz web con la que podemos gestionar nuestros contenedores y bases de datos. Podemos acceder desde la cuenta de desarrollador de la universidad:</p> <p></p> <p></p> <p>La interfaz web permite:</p> <ul> <li>Crear, visualizar, editar y borrar tipos de registros, registros, etc.</li> <li>Estad\u00edsticas de uso</li> <li>Administraci\u00f3n de acceso  Configuraci\u00f3n de despliegue</li> </ul> <p>Ejemplo de visualizaci\u00f3n de tipos de registros:</p> <p></p>"},{"location":"teoria/icloud/icloud.html#cloudkit-trabaja-sobre-registros-en-icloud","title":"CloudKit trabaja sobre registros en iCloud","text":"<p>CloudKit proporciona una forma de mover datos estructurados entre tu aplicaci\u00f3n y iCloud.</p> <p>A diferencia de las bases de datos relacionales tradicionales, en las que el modelo de datos se basa en tablas, en CloudKit se trabaja con tipos de registros. </p> <p>Un tipo de registro se define din\u00e1micamente, en tiempo de ejecuci\u00f3n de la app, por un nombre y un conjunto de claves. Una instancia concreta de un registro tiene un identificador \u00fanico y es un diccionario de parejas clave-valor con cada clave representando un campo del registro.</p> <p>El valor de cada campo suele ser un tipo de datos simple como una cadena, una fecha o un n\u00famero, pero es posible almacenar tambi\u00e9n bloques de datos arbitrarios (ficheros),</p> <p>Es posible guardar en los valores referencias a otros registros, permitiendo definir relaciones entre registros.</p> <p>Por ejemplo, en la siguiente figura se muestran dos tipos de registros con sus campos asociados. El nombre del primer tipo de registro es <code>Artwork</code> y el del segundo <code>Artist</code>.</p> <p></p> <p>Nota</p> <p>En iCloud se dispone de dos tipos de entornos: el entorno de desarrollo y el de producci\u00f3n. Cuando se desarrolla la app se construyen de forma din\u00e1mica los tipos de registros, con sus identificadores y sus campos. Despu\u00e9s se debe desplegar estos tipos de registros al entorno de producci\u00f3n, en donde ya no es posible modificar los tipos de registro.</p>"},{"location":"teoria/icloud/icloud.html#registros","title":"Registros","text":"<p>Una base de datos est\u00e1 compuesta de registros:</p> <p></p> <p>Las instancias de registro son objetos de la clase CKRecord.</p> <p>Cada instancia es un conjunto de parejas clave y valor (determinados por el tipo de registro) y tiene un identificador \u00fanico, un objeto de la clase <code>CKRecord.ID</code>. Este identificador \u00fanico podemos proporcionarlo en el momento de creaci\u00f3n del registro o podemos dejar que se inicializa autom\u00e1ticamente, si no lo definimos.</p> <p>Para crear una instancia de registro es necesario identificar el tipo de registro, definido por un <code>String</code>:</p> <pre><code>let artistaRecord = CKRecord(recordType: \"Artista\")\n</code></pre> <p>Si es la primera vez que se crea un registro de ese tipo, se crea el tipo de registro din\u00e1micamente en la base de datos.</p> <ul> <li>Una vez creado el registro se a\u00f1aden valores a sus campos (que   tambi\u00e9n se crean din\u00e1micamente):</li> </ul> <pre><code>artistaRecord[\"artista\"] = \"Jonhn Lennon\"\nlet formatter = DateFormatter()\nformatter.dateFormat = \"yyyy/MM/dd\"\nartistaRecord[\"fechanacimiento\"] = formatter.date(from: \"1940/10/09\")!\n</code></pre>"},{"location":"teoria/icloud/icloud.html#datos-en-los-registros","title":"Datos en los registros","text":"<p>Es posible definir los siguientes tipos de valores que pueden haber en los campos de los registros:</p> <ul> <li><code>NSString</code> (<code>String</code>): Cadenas</li> <li><code>NSNumber</code> (<code>Int</code>, <code>Double</code>, ...): N\u00fameros, incluidos enteros y punto flotante.</li> <li><code>NSData</code>: Bytes arbitrarios de datos (por ejemplo, la   serializaci\u00f3n binaria de un <code>struct</code>. No usar para almacenar   ficheros binarios grandes, usar <code>CKAsset</code> en su lugar.</li> <li><code>NSDate</code>: Fechas</li> <li><code>CLLocation</code>: Coordenadas geogr\u00e1ficas</li> <li><code>CKRecord.Reference</code>: Referencias a otros registros para crear relaciones entre ellos.</li> <li><code>CKAsset</code>: Fichero binario.</li> <li>Arrays de todo lo anterior</li> </ul>"},{"location":"teoria/icloud/icloud.html#grabacion-de-registros","title":"Grabaci\u00f3n de registros","text":"<p>Se a\u00f1aden registros a una base de datos usando la funci\u00f3n <code>save</code>, a la que hay que pasar un bloque que recibe el registro salvado y un error (en caso en que no se haya podido salvar).</p> <pre><code>privateDB.save(toDoItemRecord, completionHandler: {\n    (record: CKRecord?, error: Error?) in\n    print(\"Error: \\(String(describing: error))\")\n})\n</code></pre>"},{"location":"teoria/icloud/icloud.html#relaciones-entre-registros-referencias","title":"Relaciones entre registros: referencias","text":"<p>Es posible definir relaciones entre los registros. Por ejemplo un <code>Artwork</code> est\u00e1 relacionado con un <code>Artist</code>. Son similares a las claves ajenas en el tradicional modelo relacional con las que se implementan relaciones muchos-a-uno.</p> <p></p> <p></p> <p>La clase CKRecord.Reference es la utilizada para definir estas relaciones:</p> <pre><code>itemRecord[\"owningList\"] = CKRecord.Reference(record: listRecord, action: .deleteSelf)\n</code></pre> <p>La constante <code>.deleteSelf</code> indica que si el registro referenciado se borra, el propio registro tambi\u00e9n debe borrarse (borrado en cascada). La otra posible acci\u00f3n es <code>.none</code>.</p>"},{"location":"teoria/icloud/icloud.html#queries","title":"Queries","text":"<p>Para realizar una consulta se debe utilizar la clase <code>CKQuery</code> para buscar objetos que cumplen una determinada condici\u00f3n en una base de datos.</p> <p>La consulta almacena los par\u00e1metros de b\u00fasqueda, incluyendo el tipo de registros a buscar, el criterio (predicado) a aplicar, y el par\u00e1metro de ordenaci\u00f3n que aplicar a los resultados.</p> <p>El objeto de la b\u00fasqueda se usa para ejecutar una consulta en la base de datos usando el m\u00e9todo <code>perform</code></p> <p>Se le pasa un manejador al que se llamar\u00e1 cuando se obtengan los resultados. La operaci\u00f3n de b\u00fasqueda se restringe a los objetos de una zona (se pasa <code>nil</code> para la zona por defecto).</p> <p>Para realizar consultas con m\u00e1s control sobre el n\u00famero de registros devueltos, o utilizar un cursor definido por el l\u00edmite de registros devueltos, hay que realizar una <code>CKQueryOperation</code>.</p> <p>Por ejemplo, la query que devuelve todos los registros de tipo \"Tarea\" de la base de datos privada del usuario actual es la siguiente (se ha a\u00f1adido c\u00f3digo de ejemplo en el que se actualiza el array de tareas por hacer y se actualiza la vista de la tabla)</p> <pre><code>let privateDB = CKContainer.default().privateCloudDatabase\nlet query = CKQuery(recordType: \"Tarea\", predicate: NSPredicate(value:true))\nprivateDB.perform(query, inZoneWith: nil, completionHandler: {\n    (results, error) in\n    if error == nil {\n        for result in results! {\n            if let nombre = result[\"nombre\"] {\n                let toDoItem = ToDoItem(nombre: nombre as! String, publica: false)\n                self.toDoItems.append(toDoItem)\n            }\n        }\n        DispatchQueue.main.async( execute: {\n            self.tableView.reloadData()\n        })\n    } else {\n        print(\"Query error: \\(String(describing: error))\")\n    }\n})\n</code></pre> <p>Importante</p> <p>Para que funcione la consulta que recupera todos los registros de un tipo hay que crear en CloudKit Console un \u00edndice queryable sobre el campo nativo <code>recordName</code>.</p> <p>Otros ejemplos de predicados (consultar CKQuery y NSPredicate)</p> <pre><code>let predicate = NSPredicate(format: \"nombre BEGINSWITH 'Limpiar'\")\nlet predicate = NSPredicate(format: \"favoriteColors CONTAINS 'red'\")\n</code></pre> <p>La operaci\u00f3n <code>perform(_:inZoneWith:completionHandler:)</code> aparece como deprecated desde iOS 15. Si nos dirigimos a versiones posteriores, en su lugar podemos utilizar <code>fetch(withQuery:completionHandler:)</code> de la siguiente forma:</p> <pre><code>privateDB.fetch(withQuery: query, completionHandler: { (result) in\n    switch result {\n        case .success(let records):\n            for (_, recordResult) in records.matchResults {\n                if case .success(let record) = recordResult {\n                    if let nombre = record[\"nombre\"] {\n                        let toDoItem = ToDoItem(nombreItem: nombre as! String, publica: false)\n                        self.toDoItems.append(toDoItem)\n                    }\n                }\n            }\n            break\n        case .failure(let error):\n            print(\"Error al cargar: \\(error)\")\n            break\n    }\n})\n</code></pre>"},{"location":"teoria/icloud/icloud.html#operaciones-con-registros-obtenidos","title":"Operaciones con registros obtenidos","text":"<p>Un ejemplo de c\u00f3digo en el que borramos los registros de tipo \"Tarea\" cuyo nombre coincide con un nombre:</p> <pre><code>func deleteTarea(_ toDoItem: ToDoItem) {\n    let query = CKQuery(recordType: \"Tarea\",\n                        predicate: NSPredicate(format: \"nombre == %@\", argumentArray: [toDoItem.nombreItem]))\n    let publicDB = CKContainer.default().publicCloudDatabase\n    publicDB.perform(query, inZoneWith: nil, completionHandler: {\n        (results, error) in\n        if error == nil {\n            for result in results! {\n                let record: CKRecord! = result as CKRecord\n                publicDB.delete(withRecordID: record.recordID, completionHandler: {\n                    (recordID, error) in print(\"Error: \\(String(describing: error))\")\n                })\n            }\n        }\n    })\n} \n</code></pre>"},{"location":"teoria/icloud/icloud.html#caracteristicas-sociales-de-cloudkit","title":"Caracter\u00edsticas sociales de CloudKit","text":"<p>CloudKit permite descubrirse entre ellos a usuarios que est\u00e1n usando nuestra app. Los usuarios podr\u00e1n compartir datos de identidad (nombre de usuario y correo elctr\u00f3nico) si:</p> <ul> <li>Est\u00e1n en los contactos del usuario actual</li> <li>Han dado el permiso a la app</li> </ul> <p>Para que otros usuarios puedan acceder a la informaci\u00f3n del usuario actual, hay que solicitarle su aprobaci\u00f3n llamando a la funci\u00f3n <code>requestApplicationPermission</code></p> <p>Se le pasa como par\u00e1metro <code>completionHandler</code> el manejador de la respuesta del usuario. Recibiremos dos par\u00e1metros, el <code>applicationPermissionStatus</code> (constante que indica lo que ha respondido el usuario) y un objeto <code>error</code> que ser\u00e1 <code>nil</code> si todo ha ido correctamente.</p> <p>Se pueden buscar los usuarios que han dado permiso y que est\u00e1n en la agenda del usuario actual por su direcci\u00f3n de correo electr\u00f3nico registrada en el Apple Id.</p> <p>La funci\u00f3n <code>discover\u200bAll\u200bIdentities(completion\u200bHandler:\u200b)</code> de <code>CKContainer</code> permite obtener estos usuarios</p> <p>Se le pasa como par\u00e1metro <code>completionHandler</code>, una funci\u00f3n que la consulta ejecutar\u00e1 cuando se obtengan los resultados. Tiene dos par\u00e1metros:</p> <ul> <li> <p>Un array de objetos <code>CKUser\u200bIdentity</code> que corresponde con los contactos del usuario que han autorizado conocerlos. Si no hay usuarios, el array estar\u00e1 vac\u00edo.</p> </li> <li> <p>Un objeto error si sucede alg\u00fan problema, o <code>nil</code> si los IDs se han obtenido correctamente.</p> </li> </ul> <p>Ejemplo de c\u00f3digo:</p> <pre><code>let container = CKContainer.default()\nprint(\"Container: \")\nprint(container)\n// Solicitamos permiso para que el usuario se haga descubrible\ncontainer.requestApplicationPermission(\n    CKContainer.ApplicationPermissions.userDiscoverability,\n    completionHandler: { (permissionStatus, error) in\n        print(\"Permiso concedido: \" +\n            \"\\(permissionStatus == CKContainer.ApplicationPermissionStatus.granted)\")})\n\n// Obtenemos los usuarios de la app que han dado permiso\ncontainer.discoverAllIdentities(completionHandler: { (optUsers, error) in\n    if let users = optUsers {\n        for user in users {\n            print(user)\n            // usamos user.userRecordID para buscar\n            // registros p\u00fablicos de un usuario\n        }\n    }})\n</code></pre>"},{"location":"teoria/icloud/icloud.html#suscripciones","title":"Suscripciones","text":"<p>Es posible hacer consultas \"permanentes\" que son ejecutadas en background por el servidor tras cada registro salvado. </p> <p>Generan notificaciones push con los resultados.</p>"},{"location":"teoria/icloud/icloud.html#cloudkit-js","title":"CloudKit JS","text":"<p>CloudKit JS es una librer\u00eda que proporciona un API JavaScript para acceder a los datos en los contenedores CloudKit.</p> <p>Lanzado en WWDC 2015.</p> <p>Necesita un token generado en CloudKit Console para acceso seguro al API en la conexi\u00f3n servidor-servidor.</p> <p>Permite autentificarse y realizar peticiones seguras JavaScript desde una aplicaci\u00f3n web para acceder a los datos de CloudKit.</p> <p>Sistema usado por la interfaz web de las apps de Apple en la p\u00e1gina web de iCloud (Notas, Photos, etc.)</p> <p>Un ejemplo de aplicaci\u00f3n web presentado por Apple en el que se demuestra el uso de esta librer\u00eda  CloudKit Catalog</p>"},{"location":"teoria/icloud/icloud.html#demo_1","title":"Demo","text":""},{"location":"teoria/icloud/icloud.html#app-democloudkit","title":"App DemoCloudKit","text":"<p>Vamos a hacer una demostraci\u00f3n de una sencilla app llamada <code>DemoCloudKit</code>. Est\u00e1 basada en un tutorial de la web Kodeco (anteriormente conocida como Ray Wenderlich). Se puede descargar desde este enlace.</p> <p></p> <p>La app tiene como bundle id <code>es.ua.mudsdm.DemoCloudKit</code>.</p>"},{"location":"teoria/icloud/icloud.html#creacion-del-contenedor","title":"Creaci\u00f3n del contenedor","text":"<p>Debemos crear un perfil de aprovisionamiento con capacidad de acceso a CloudKit. </p> <p>Para ello creamos primero el identificador del contenedor de CloudKit. </p> <p>Podemos hacerlo desde la p\u00e1gina con el listado de contenedores de CloudKit, pulsando el bot\u00f3n <code>+</code> junto a Identifiers. Tambi\u00e9n se puede hacer autom\u00e1ticamente desde Xcode si somos administradores de la cuenta con la que estamos logeados.</p> <p></p> <p>Despu\u00e9s debemos rellenar el identificador del contenedor. Como el bundle id de la app es <code>es.ua.mudsdm.DemoCloudKit</code> el identificador del contenedor ser\u00e1:</p> <pre><code>iCloud.es.ua.mudsdm.DemoCloudKit\n</code></pre> <p>Hay que tener mucho cuidado porque una vez creados los identificadores de contenedores no se pueden borrar.</p> <p></p>"},{"location":"teoria/icloud/icloud.html#creacion-del-app-id-y-asignacion-del-contenedor","title":"Creaci\u00f3n del App ID y asignaci\u00f3n del contenedor","text":"<p>Una vez creado el identificador del contenedor, debemos crear el App ID con el permiso para iCloud y seleccionar el contenedor que vamos a usar en ese App ID.</p> <p>Creamos el App ID con el bundle ID de la aplicaci\u00f3n.</p> <p></p> <p>Marcamos el servicio iCloud y configuramos el contenedor.</p> <p></p> <p>A\u00f1adimos el contenedor reci\u00e9n creado, el que tiene el identificador <code>iCloud.es.ua.mudsdm.DemoCloudKit</code>.</p> <p></p>"},{"location":"teoria/icloud/icloud.html#creacion-del-perfil-de-aprovisionamiento","title":"Creaci\u00f3n del perfil de aprovisionamiento","text":"<p>Creamos para la demo el perfil de aprovisionamiento con el App ID anterior. </p> <p></p>"},{"location":"teoria/icloud/icloud.html#actualizacion-de-capacidades-de-la-app","title":"Actualizaci\u00f3n de capacidades de la app","text":"<p>Escribimos como Bundle Identifier el definido por el App ID. En el caso de la demo usaremos <code>es.ua.mudsdm.DemoCloudKit</code>. </p> <p>Actualizamos las capacidades en Xcode a\u00f1adiendo la capacidad iCloud y activando CloudKit.</p> <p>Seleccionamos el equipo de la UA y autom\u00e1ticamente se cargar\u00e1 el perfil reci\u00e9n creado.</p>"},{"location":"teoria/icloud/icloud.html#cloudkit-console_1","title":"CloudKit Console","text":"<p>Comprobamos los permisos de los miembros del equipo de la universidad en CloudKit Console. El administrador del equipo de desarrollo puede gestionar permisos para el resto de miembros. Los permisos se definen a nivel de contenedor. </p> <p></p> <p>Revisamos el esquema de datos y los registros. Hemos creado manualmente dos tipos de registros:</p> <ul> <li>Establishmet</li> <li>Note</li> </ul> <p></p> <p>Y hemos creado un par de registros concretos de esos tipos de registros. </p> <p>Examinamos los tipos de registro, sus campos, los datos, las relaciones y las bases de datos en las que est\u00e1n creados.</p>"},{"location":"teoria/icloud/icloud.html#ejecutamos-la-app-y-mostramos-el-codigo","title":"Ejecutamos la app y mostramos el c\u00f3digo","text":"<p>En la app podemos navegar por los establecimientos y vemos como se muestran sus caracter\u00edsticas. Tambi\u00e9n podemos comprobar las notas privadas creadas asociadas con cada establecimiento.</p> <p>Probamos a modificar alg\u00fan dato en CloudKit Console y a comprobar que se actualiza en la aplicaci\u00f3n.</p> <p>Todo el c\u00f3digo relacionado con CloudKit est\u00e1 en la carpeta <code>Model</code>.</p> <ul> <li>Se definen dos clases que mapean los registros:   <code>Establishment.swift</code> y <code>Note.swift</code>.</li> <li>La clase <code>Model.swift</code> contiene m\u00e9todos para recuperar los registros   de iCloud mediante queries.</li> </ul>"},{"location":"teoria/icloud/icloud.html#referencias","title":"Referencias","text":"<ul> <li>P\u00e1gina principal tecnolog\u00eda CloudKit</li> <li>CloudKit Documentation</li> <li>CloudKit Quick Start</li> <li>iCloud Design Guide</li> <li>Providing User Access to CloudKit Data</li> <li>Changing Access Controls on User Data </li> <li>Responding to Requests to Delete Data </li> <li>Identifying an App's Containers</li> <li>CloudKit JS</li> <li>Tutorial de Kodeco sobre CloudKit</li> </ul>"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html","title":"Sesi\u00f3n 0: Planificaci\u00f3n bloque iOS","text":""},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#planificacion","title":"Planificaci\u00f3n","text":"<ul> <li>Semana 1: Firma, aprovisionamiento y distribuci\u00f3n de apps </li> <li>Semana 2: Notificaciones</li> <li>Semana 3: iCloud</li> <li>Semana 4: Mapas y localizaci\u00f3n</li> <li>Semana 5: Extensiones y App Groups</li> <li>Semana 6: Publicaci\u00f3n en App Store y compras In-App</li> </ul>"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#entregas-de-practicas","title":"Entregas de pr\u00e1cticas","text":"<ul> <li>Entregas en Moodle, normalmente una entrega cada semana</li> <li>Plazo m\u00e1ximo: una semana despu\u00e9s del final de la asignatura (7 de junio)</li> <li>Recomendable realizar los ejercicios semana a semana</li> </ul>"},{"location":"teoria/introduccion-servicios-ios/introduccion-servicios-ios.html#recursos","title":"Recursos","text":"<ul> <li>En cada sesi\u00f3n presentaremos enlaces a documentaci\u00f3n de referencia y gu\u00edas, normalmente de Apple. </li> <li>Enlaces a los frontales de Apple de distintas tecnolog\u00edas que   veremos en la asignatura:<ul> <li>Apple Develop</li> <li>Notificaciones</li> <li>iCloud</li> <li>Mapas y localizaci\u00f3n</li> <li>App Extensions</li> <li>App Store</li> <li>Compras in-App</li> </ul> </li> </ul>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html","title":"2. Mapas y localizaci\u00f3n","text":""},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mapas-y-localizacion","title":"Mapas y localizaci\u00f3n","text":""},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mapkit","title":"MapKit","text":""},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#aspectos-basicos-de-mapkit","title":"Aspectos b\u00e1sicos de MapKit","text":"<p>Map Kit es el framework de Apple para trabajar con mapas.</p> <p>Permite muchas funcionalidades: pan y zoom, anotaciones, localizaci\u00f3n, overlays, b\u00fasquedas, rutas, direcciones, etc.</p> <p>Junto con los servicios de localizaci\u00f3n proporciona la forma de incluir datos geogr\u00e1ficos en nuestras apps.</p> <p> </p> <p>Los mapas permiten a los usuarios a visualizar datos geogr\u00e1ficos de una forma f\u00e1cil de entender. Por ejemplo, un mapa puede mostrar datos de sat\u00e9lite de un \u00e1rea, o una visualizaci\u00f3n tridimensional de una perspectiva de la zona.</p> <p>El framework Map Kit permite embeber en tu app un map completamente funcional, que soporta funcionalidades similares a la de la app <code>Mapas</code>.</p> <p>Con Map Kit puedes incorporar en tu app vistas de un punto geogr\u00e1fico concreto. Adem\u00e1s, el framework te permite a\u00f1adir capas de informaci\u00f3n sobre el mapa, moverlo, o tomar instant\u00e1neas de un mapa para imprimir.</p> <p>Un ejemplo de la app <code>Mapas</code> mostrando una vista 3D de Alicante:</p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#geometria-de-los-mapas","title":"Geometr\u00eda de los mapas","text":"<p>Map Kit usa una proyecci\u00f3n Mercator, que es un tipo espec\u00edfico de proyecci\u00f3n cil\u00edndrica.</p> <p>Una coordenada se define por una latitud y una longitud.</p> <ul> <li> <p>La latitud es la distancia angular (en grados: de -90.0 a 90.0) desde el punto de la superficie hasta el ecuador. Las latitudes positivas definen puntos por encima del ecuador y las negativas por debajo.</p> </li> <li> <p>La longitud es la distancia angular (en grados: de -180.0 a 180.0) desde el punto de la superficie hasta el meridiano 0 (meridianto de Greenwich). Las longitudes positivas definen puntos al este del meridiano y las negativas al oeste.</p> </li> </ul> <p>La estructura <code>CLLocationCoordinate2D</code> representa esta estructura. Por ejemplo, para crear una localizaci\u00f3n situada en Alicante:</p> <pre><code>let alicanteLocation =  CLLocationCoordinate2D(latitude: 38.3453, \n                                               longitude: -0.4831)\n</code></pre> <p>Un punto en el mapa se define por los valores <code>x</code> e <code>y</code> en la proyecci\u00f3n de Mercator. Se define utilizando la estructura <code>MKMapPoint</code>. Se utiliza para especificar la posici\u00f3n y forma de los overlays que podemos pintar sobre el mapa.</p> <p> </p> <p>Un punto es una unidad gr\u00e1fica asociada con el sistema de coordenadas de una vista. Los puntos en el mapa y las coordenadas deben convertirse en puntos antes de dibujar contenido en una vista. Los puntos individuales se definen usando la estructura <code>CGPoint</code> y las \u00e1reas usando <code>CGSize</code> y <code>CGRect</code>. Consultar las funciones del API de geometr\u00eda y los tipos de datos en este enlace</p> <p>Para almacenar los datos en ficheros es preferible usar coordenadas de mapas.</p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anadir-un-mapa-en-nuestra-app","title":"A\u00f1adir un mapa en nuestra app","text":"<p>Para poder distribuir apps que trabajen con el servicio de mapas es necesario activar en la app el entitlement correspondiente, activando los servicios que necesitamos. Debemos tener un perfil de aprovisionamiento aprobado con un App ID que soporte estos servicios.</p> <p> </p> <p>No es necesario para el desarrollo y para las pruebas en el simulador. No utilizaremos por tanto ning\u00fan perfil de aprovisionamiento especial para la pr\u00e1ctica.</p> <p>La clase <code>MKMapView</code> es una interfaz autocontenida para presentar los mapas en tu app. Proporciona todo el soporte para mostrar los datos del mapa, gestionar las interacciones del usuario y hospedar el contenido proporcionado por tu app. Debes importar <code>MapKit</code>.</p> <p>No debes hacer una subclase de <code>MKMapView</code> sino embeberla tal cual en la jerarqu\u00eda de vistas de tu app:</p> <ul> <li>Usando el Interface Builder puedes arrastrar un objeto Map   view a la vista o ventana apropiada.</li> <li>Para a\u00f1adir un mapa por programa, crea una instancia de la clase   <code>MKMapView</code>, inicial\u00edzala con el m\u00e9todo   <code>initWithFrame:</code>   y a\u00f1\u00e1dela como una subvista a tu ventana o a tu vista.</li> </ul> <p>Por \u00faltimo debes actualizar el delegado con un objeto que cumpla el protocolo <code>MKMapViewDelegate</code>.</p> <p>Ejemplo de c\u00f3digo para a\u00f1adir un mapa mediante programa:</p> <pre><code>import UIKit\nimport MapKit\n\nclass ViewController: UIViewController, MKMapViewDelegate {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        let map = MKMapView(frame:\n                                CGRect(x: 0, y: 0,\n                                       width: self.view.frame.width,\n                                       height: self.view.frame.height))\n        self.view.addSubview(map)\n        map.delegate = self\n    }\n}\n</code></pre> <p>El resultado tiene el siguiente aspecto:</p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#inicializacion-del-mapa","title":"Inicializaci\u00f3n del mapa","text":"<p>Podemos tambi\u00e9n inicializar el mapa cuando se crea usando el Interface Builder, usando un <code>didSet</code> en el outlet <code>mapView</code> que definimos arrastrando desde el storyboard:</p> <pre><code>class ViewController: UIViewController, MKMapViewDelegate  {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view.\n    }\n\n    @IBOutlet weak var mapView: MKMapView! {\n        didSet {\n            mapView.mapType = .standard\n            mapView.delegate = self\n            let alicanteLocation = \n                CLLocationCoordinate2D(latitude: 38.3453, \n                                       longitude: -0.4831)\n            centerMapOnLocation(mapView: mapView, loc: alicanteLocation)\n        }\n    }\n\n    func centerMapOnLocation(mapView: MKMapView, loc: CLLocationCoordinate2D) {\n        let regionRadius: CLLocationDistance = 4000\n        let coordinateRegion =\n            MKCoordinateRegion(center: loc,\n                               latitudinalMeters: regionRadius,\n                               longitudinalMeters: regionRadius)\n        mapView.setRegion(coordinateRegion, animated: true)\n    }\n\n    ...\n}\n</code></pre> <p>Para que los controles del mapa funcionen correctamente es necesario asignar el delegado <code>MKMapViewDelegate</code>a un objeto que defina las funciones de este delegado. Lo m\u00e1s sencillo es definir el propio <code>View Controller</code> como el delegado.</p> <p>La propiedad <code>region</code> del mapa controla el \u00e1rea del mapa mostrada. Contiene al mismo tiempo el punto de longitud y latitud en el que el mapa est\u00e1 centrado y la zona visible, determinando de forma impl\u00edcita el zoom del mapa.</p> <p>Por ejemplo, el c\u00f3digo anterior centra el mapa en Alicante y muestra una zona de 4 km. de alto y ancho.</p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#tipos-de-mapas","title":"Tipos de mapas","text":"<p>La definici\u00f3n del tipo de mapa se controla con la propiedad <code>mapType</code> del mapa.</p> <p>Puede tener los valores:</p> <pre><code>enum MKMapType : UInt {\n    case standard\n    case satellite\n    case hybrid\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#ejemplo-de-seleccion-del-tipo-de-mapa-con-un-segmentedcontrol","title":"Ejemplo de selecci\u00f3n del tipo de mapa con un <code>SegmentedControl</code>","text":"<p>Supongamos un <code>SegmentedControl</code> con los valores <code>Mapa</code> y <code>Sat\u00e9lite</code>. Podemos cambiar la visualizaci\u00f3n del mapa en la acci\u00f3n definida en el View Controller que contiene el <code>mapView</code>:</p> <pre><code>enum TipoMapa: Int {\n    case mapa = 0\n    case satelite\n}\n\n...\n\n// En el ViewController\n\n@IBAction func seleccion(sender: UISegmentedControl) {\n    let tipoMapa = TipoMapa(rawValue: sender.selectedSegmentIndex)!\n    switch (tipoMapa) {\n        case .mapa:\n            mapView.mapType = MKMapType.standard\n        case .satelite:\n            mapView.mapType = MKMapType.satellite\n    }\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#uso-del-delegado","title":"Uso del delegado","text":"<p>Hemos visto que Lo m\u00e1s sencillo es definir como delegado el view controller en el que se incluye el mapa.</p> <p>El objeto delegado puede implementar las funciones del protocolo <code>MKMapViewDelegate</code> donde recibe los eventos relacionados con el mapa:</p> <ul> <li>Cambios en la regi\u00f3n visible del mapa.</li> <li>La carga de zonas del mapa de la red.</li> <li>Cambios en la localizaci\u00f3n del usuario.</li> <li>Cambios asociados con anotaciones y overlys.</li> </ul> <p>Por ejemplo:</p> <pre><code>func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {\n    print(\"Cambiada la posici\u00f3n del mapa: \\(mapView.centerCoordinate)\")\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anotaciones","title":"Anotaciones","text":"<p>Las anotaciones permiten resaltar coordenadas espec\u00edficas del mapa y proporcionar informaci\u00f3n adicional sobre ellas.</p> <p>Puedes usar anotaciones para resaltar direcciones, puntos de inter\u00e9s y otros tipos de destinos.</p> <p>Cuando se muestran en el mapa, las anotaciones tienen alg\u00fan tipo de imagen para identificar su localizaci\u00f3n y tambi\u00e9n pueden tener un bocadillo (callout) que proporciona informaci\u00f3n y enlaces hacia m\u00e1s contenido.</p> <p>En la imagen se muestra una vista est\u00e1ndar en forma de chincheta para marcar un lugar y un callout que muestra m\u00e1s informaci\u00f3n.</p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clases-relacionadas","title":"Clases relacionadas","text":"<p>Para mostrar una anotaci\u00f3n en un mapa necesitamos dos objetos:</p> <ul> <li> <p>Un objeto <code>annotation</code>, que es un objeto que cumple el     protocolo     <code>MKAnnotation</code>     y que gestiona los datos de la anotaci\u00f3n.</p> </li> <li> <p>Una vista de la anotaci\u00f3n, que es una vista (derivada de la     clase <code>MKAnnotationView</code>     usada para dibujar la representaci\u00f3n visual de la anotaci\u00f3n sobre     la superficie del mapa (una \"chincheta\" por defecto).</p> </li> </ul>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#el-protocolo-mkannotation","title":"El protocolo <code>MKAnnotation</code>","text":"<p>El protocolo <code>MKAnnotation</code> define los m\u00e9todos que deben cumplir los objetos que vayan a implementar una anotaci\u00f3n:</p> <pre><code>var coordinate: CLLocationCoordinate2D { get }\nvar title: String? { get }\nvar subtitle: String? { get }\n</code></pre> <ul> <li><code>coordinate</code>: coordenadas de la anotaci\u00f3n</li> <li><code>title</code>: cadena mostrada en el callout</li> <li><code>subtitle</code>: cadena subt\u00edtulo mostrada en el callout</li> </ul> <p>Podemos conformar el protocolo en cualquier clase. Por ejemplo, podemos definir una clase <code>Pin</code>:</p> <pre><code>class Pin:  NSObject, MKAnnotation {\n    var coordinate: CLLocationCoordinate2D\n    var title: String?\n    var subtitle: String?\n\n    init(num: Int, coordinate: CLLocationCoordinate2D) {\n        self.title = \"Pin \\(num)\"\n        self.subtitle = \"Un bonito lugar\"\n        self.coordinate = coordinate\n        super.init()\n    }\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#mkannotationview","title":"<code>MKAnnotationView</code>","text":"<p>La clase <code>MKAnnotationView</code> permite bastante flexibilidad para definir las distintas caracter\u00edsticas de las vistas de las anotaciones.</p> <p>Permite definir la imagen de la anotaci\u00f3n, con su propiedad <code>image</code> y definir las caracter\u00edsticas del callout que aparecer\u00e1 cuando el usuario pinche sobre la imagen, as\u00ed como mantener el estado del mismo. Cuando la anotaci\u00f3n est\u00e1 seleccionada, el callaout est\u00e1 activo.</p> <p>La subclase <code>MKPinAnnotationView</code> proporciona unos valores por defecto que podemos usar (por ejemplo, la imagen de la chincheta).</p> <p>Para crear una anotaci\u00f3n (o, m\u00e1s precisamente, una vista de una anotaci\u00f3n), debemos usar la funci\u00f3n <code>mapView(_:viewFor:)</code> en el objeto delegado del mapa. Esta funci\u00f3n proporciona una vista cuando las coordenadas de la anotaci\u00f3n est\u00e1n la regi\u00f3n visible y el mapa la solicita. </p> <pre><code>func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) \n                          -&gt; MKAnnotationView?\n</code></pre> <p>En la implementaci\u00f3n de esta funci\u00f3n debemos construir una vista asociada a la anotaci\u00f3n que nos pasan y devolverla para que el mapView la gestione o devolver <code>nil</code> si queremos que se muestre la vista est\u00e1ndar.</p> <p>Por ejemplo:</p> <pre><code>func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? {\n    print(\"Devolviendo vista para anotaci\u00f3n: \\(annotation)\")\n    let view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: nil)\n    view.pinTintColor = UIColor.red\n    view.animatesDrop = true\n    view.canShowCallout = true\n    return view;\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#anadir-anotaciones-en-el-mapa","title":"A\u00f1adir anotaciones en el mapa","text":"<p>Para a\u00f1adir una anotaci\u00f3n al mapa hay que usar el m\u00e9todo <code>addAnnotation</code> del <code>viewMap</code>.</p> <p>Por ejemplo, podemos crear una anotaci\u00f3n en el centro del mapa creando una instancia de <code>Pin</code> (la clase definida anteriormente, que cumple el protocolo <code>MKAnnotation</code>) que inicializamos con un n\u00famero (variable definida en el <code>viewController</code> que vamos incrementado):</p> <pre><code>let pin = Pin(num: numPin, coordinate: mapView.centerCoordinate)\nmapView.addAnnotation(pin)\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#elementos-en-el-callout","title":"Elementos en el callout","text":"<p>Es posible definir en el callout una imagen en su parte izquierda y un bot\u00f3n en la parte derecha.</p> <p> </p> <p>Hay que actualizar las propiedades de la vista <code>leftCalloutAccessoryView</code> y <code>rightCalloutAccessoryView</code> con objetos <code>UIView</code>. En la parte derecha es com\u00fan usar un objeto <code>UIButton</code> con tipo <code>UIButtonTypeDetailDisclosure</code>.</p> <p>Por ejemplo, podemos mostrar im\u00e1genes en la parte izquierda del callout, un thumbnail con la foto del sitio en el que est\u00e1 situada la anotaci\u00f3n. Podemos guardar la imagen en el objeto modelo annotation y despu\u00e9s inicializar la imagen del callout con esa imagen.</p> <p>Por simplificar, guardamos dos im\u00e1genes predefinidas seg\u00fan el n\u00famero del pin sea par o impar. Podr\u00edamos tambi\u00e9n tener una colecci\u00f3n de im\u00e1genes y guardar en el pin la m\u00e1s cercana a sus coordenadas.</p> <pre><code>class Pin:  NSObject, MKAnnotation {\n    var coordinate: CLLocationCoordinate2D\n    var title: String\n    var subtitle: String\n    var thumbImage: UIImage\n\n    init(num: Int, coordinate: CLLocationCoordinate2D) {\n        self.title = \"Pin \\(num)\"\n        self.subtitle = \"Un bonito lugar\"\n        self.coordinate = coordinate\n        if (num % 2 == 0) {\n            self.thumbImage = UIImage(named: \"alicante1_thumb.png\")!\n        } else {\n            self.thumbImage = UIImage(named: \"alicante2_thumb.png\")!\n        }\n        super.init()\n    }\n}\n</code></pre> <p>La actualizaci\u00f3n del callout se hace en el mismo m\u00e9todo <code>mapView(_:viewFor</code>) que devuelve la vista de una anotaci\u00f3n: </p> <pre><code>func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? {\n    print(\"Devolviendo vista para anotaci\u00f3n: \\(annotation)\")\n    let pin = annotation as? Pin\n    let view = MKPinAnnotationView(annotation: annotation, reuseIdentifier: nil)\n\n    view.pinTintColor = UIColor.red\n    view.animatesDrop = true\n    view.canShowCallout = true\n    let thumbnailImageView = UIImageView(frame: CGRect(x:0, y:0, width: 59, height: 59))\n    thumbnailImageView.image = pin?.thumbImage\n    view.leftCalloutAccessoryView = thumbnailImageView\n    view.rightCalloutAccessoryView = UIButton(type:UIButton.ButtonType.detailDisclosure)\n    return view;\n}\n</code></pre> <p>Podemos saber que se ha pulsado un bot\u00f3n de un callout usando el m\u00e9todo del delegado <code>mapView(_:annotationView:calloutAccessoryControlTapped:)</code>. En ese caso podr\u00edamos, por ejemplo, activar un segue, pas\u00e1ndole como par\u00e1metro la vista de la anotaci\u00f3n que se ha pulsado.</p> <pre><code>    func mapView(_ mapView: MKMapView, annotationView view: MKAnnotationView, calloutAccessoryControlTapped control: UIControl) {\n        performSegue(withIdentifier: \"DetalleImagen\", sender: view)\n    }\n</code></pre> <p>En el m\u00e9todo <code>prepare(for segue: UIStoryboardSegue, sender: Any?)</code> recibiremos la vista de la anotaci\u00f3n en el par\u00e1metro <code>sender</code>. Podemos acceder a la anotaci\u00f3n a partir de la <code>mKAnnotationView</code> usando el atributo <code>annotation</code>.</p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#overlays","title":"Overlays","text":"<p>Los overlays permiten definir capas de contenido sobre una regi\u00f3n arbitraria del mapa.</p> <p> </p> <p>Est\u00e1n definidos por coordenadas en las que es posible definir conjuntos de l\u00edneas, rect\u00e1ngulos y otras formas.</p> <p>Por ejemplo, se podr\u00eda usar usar overlays para a\u00f1adir informaci\u00f3n de tr\u00e1fico sobre carreteras, o marcar los l\u00edmites de un parque o de una regi\u00f3n. </p> <p>Puedes ver una demostraci\u00f3n del uso de overlays en la app ParkView del tutorial de raywenderlich.com.</p> <p>Para mostrar un overlay sobre un mapa se deben proporcionar dos objetos:</p> <ul> <li> <p>Un objeto overlay, que es un objeto que cumple el protocolo MKOverlay y gestiona los puntos de datos del overlay.</p> </li> <li> <p>Un renderizador del overlay, que es una clase derivada de MKOverlayRenderer y que debe usarse para dibujar la representaci\u00f3n visual del overlay sobre la superficie del mapa.</p> </li> </ul> <p>Un ejemplo de c\u00f3digo de la aplicaci\u00f3n demo <code>Park View</code>:</p> <pre><code>class ParkMapOverlay: NSObject, MKOverlay {\n\n  var coordinate: CLLocationCoordinate2D\n  var boundingMapRect: MKMapRect\n\n  init(park: Park) {\n    boundingMapRect = park.overlayBoundingMapRect\n    coordinate = park.midCoordinate\n  }\n}\n</code></pre> <pre><code>class ParkMapOverlayView: MKOverlayRenderer {\n  var overlayImage: UIImage\n\n  init(overlay:MKOverlay, overlayImage:UIImage) {\n    self.overlayImage = overlayImage\n    super.init(overlay: overlay)\n  }\n\n  override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {\n    guard let imageReference = overlayImage.cgImage else { return }\n\n    let rect = self.rect(for: overlay.boundingMapRect)\n    context.scaleBy(x: 1.0, y: -1.0)\n    context.translateBy(x: 0.0, y: -rect.size.height)\n    context.draw(imageReference, in: rect)\n  }\n}\n</code></pre> <p>El overlay debe a\u00f1adirse al <code>mapView</code>:</p> <pre><code>let overlay = ParkMapOverlay(park: park)\nmapView.add(overlay)\n</code></pre> <p>Para su visualizaci\u00f3n debemos implementar el m\u00e9todo <code>mapView:rendererForOverlay:</code> en el <code>mapView</code> delegado. En el siguiente c\u00f3digo se dibujan distintos tipos de overlays:</p> <pre><code>  func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer {\n    if overlay is ParkMapOverlay {\n      return ParkMapOverlayView(overlay: overlay, overlayImage: #imageLiteral(resourceName: \"overlay_park\"))\n    } else if overlay is MKPolyline {\n      let lineView = MKPolylineRenderer(overlay: overlay)\n      lineView.strokeColor = UIColor.green\n      return lineView\n      else if ...\n    }\n\n    return MKOverlayRenderer()\n  }\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#geocoding","title":"Geocoding","text":"<p>El API de MapKit proporciona funcionalidades para realizar geocoding, transformar coordenadas del mapa en nombres de lugares y vicersa.</p> <p>La clase CLGeocoder proporciona un API que realiza estas operaciones realizando peticiones a un servicio de Apple.</p> <p>Debemos crear un objeto geocoder y realizar una petici\u00f3n llamando a uno de sus m\u00e9todos de forward geocoding o reverse geocoding.</p> <p>Las peticiones de reverse geocoding toman una longitud y latitud y obtienen una direcci\u00f3n con nombres.</p> <p> </p> <p>Las peticiones de forward geocoding hacen al rev\u00e9s: toman una direcci\u00f3n con nombres y buscan la correspondiente latitud y longitud. Estas peticiones pueden tambi\u00e9n devolver informaci\u00f3n adicional acerca de la localizaci\u00f3n especificada, como un punto de inter\u00e9s o un edificio en esa localizaci\u00f3n.</p> <p>El objeto devuelto en ambos tipos de peticiones es un CLPlacemark el caso de peticiones forward geocoding se puede devolver una lista de lugares a los que corresponde la direcci\u00f3n suministrada. </p> <p>Un placemark (marca de lugar) contiene propiedades para especificar el nombre de una calle, de una ciudad o de un pa\u00eds. Tambi\u00e9n contienen propiedades que describen caracter\u00edsticas geogr\u00e1ficas relevantes o puntos de inter\u00e9s en la localizaci\u00f3n, como los nombres de monta\u00f1as, r\u00edos, negocios o localizaciones.</p> <p>Existe un l\u00edmite en el ratio de peticiones de geocoding que puede hacer una app. Si se hacen demasiadas peticiones en un tiempo peque\u00f1o puede producirse un error.</p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#conversion-de-localizacion-en-placemarks","title":"Conversi\u00f3n de localizaci\u00f3n en placemarks","text":"<p>Con el m\u00e9todo <code>reverseGeocodeLocation</code> se puede obtener una lista de placemarks asociadas a unas coordenadas. Las llamadas al objeto geocoder son as\u00edncronas y hay que pasarle al m\u00e9todo una clausura completion handler. </p> <p>Un ejemplo de uso:</p> <pre><code>func printLocationPlacemark(location: CLLocation) {\n    let geocoder = CLGeocoder()\n    geocoder.reverseGeocodeLocation(location, \n                completionHandler: { (placemarks, error) in\n                    if error == nil {\n                        let firstLocation: CLPlacemark = placemarks?[0]\n                        print(firstLocation ?? \"No hay localizaci\u00f3n\")\n                    }\n                    else {\n                       print(\"An error occurred during geocoding\")\n                    }\n                })\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#conversion-de-placemarks-en-localizaciones","title":"Conversi\u00f3n de placemarks en localizaciones","text":"<p>Con el m\u00e9todo <code>geocodeAddressString</code> se puede pasar una direcci\u00f3n al geocoder y obtener una lista de lugares asociados (placemarks). Se obtendr\u00e1n menos lugares cuanto m\u00e1s precisa sea la direcci\u00f3n.</p> <p>Ejemplo:</p> <pre><code>func getCoordinate( addressString : String, \n        completionHandler: @escaping(CLLocationCoordinate2D, NSError?) -&gt; Void ) {\n    let geocoder = CLGeocoder()\n    geocoder.geocodeAddressString(addressString) { (placemarks, error) in\n        if error == nil {\n            if let placemark = placemarks?[0] {\n                let location = placemark.location!\n\n                completionHandler(location.coordinate, nil)\n                return\n            }\n        }\n\n        completionHandler(kCLLocationCoordinate2DInvalid, error as NSError?)\n    }\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#otras-caracteristicas-busquedas-rutas-y-3d","title":"Otras caracter\u00edsticas: b\u00fasquedas, rutas y 3D","text":"<p>No tenemos tiempo de verlo, pero el API tambi\u00e9n proporciona la posibilidad de realizar b\u00fasquedas y rutas en los mapas:</p> <p> </p> <p>As\u00ed como la posibilidad de mostrar el mapa en 3D:</p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#localizacion","title":"Localizaci\u00f3n","text":"<p>Mediante el framework <code>Core Location</code> es posible obtener la localizaci\u00f3n del dispositivo m\u00f3vil. </p> <p>Los datos de localizaci\u00f3n pueden ser muy \u00fatiles para proporcionar servicios al usuario en distintos tipos de apps, como redes sociales, compras o navegaci\u00f3n.</p> <p>Este framework proporciona bastantes funcionalidades que podemos usar para obtener y monitorizar la localizaci\u00f3n actual del dispositivo:</p> <ul> <li> <p>El servicio de localizaci\u00f3n de cambios-significativos proporciona una forma de bajo consumo de obtener la localizaci\u00f3n actual y ser notificado cuando ha ocurrido un cambio significativo.</p> </li> <li> <p>El servicio de localizaci\u00f3n est\u00e1ndar ofrece una forma altamente configurable de obtener la localizaci\u00f3n actual y de hacer un seguimiento de los cambios.</p> </li> <li> <p>La monitorizaci\u00f3n de regiones nos permite monitorizar regiones geogr\u00e1ficas y regiones definidas por beacons de Bluetooth de baja energ\u00eda.</p> </li> </ul> <p>La  clase principal del framework es   <code>CLLocationManager</code></p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#activacion-de-los-servicios-de-localizacion","title":"Activaci\u00f3n de los servicios de localizaci\u00f3n","text":"<p>Si la app requiere servicios de localizaci\u00f3n para funcionar correctamente, debes incluir la clave <code>UIRequiredDeviceCapabilities</code> en el fichero <code>Info.plist</code> de la app. La App Store usa la informaci\u00f3n en esta clava para prevenir la descarga de la app a dispositivos que no contienen estos servicios. Puedes no a\u00f1adir esta clave si quieres permitir descargar la app aunque no est\u00e9 disponible el servicio.</p> <p>El valor de la clave es un array de cadenas indicando las caracter\u00edsticas que requiere la app. En el caso de los servicios de localizaci\u00f3n son relevantes las cadenas <code>location-services</code> y <code>gps</code>. La primera si se requieren servicios de localizaci\u00f3n en general y la segundo si se requiere la precisi\u00f3n ofrecida por el GPS.</p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#solicitar-informacion-al-usuario","title":"Solicitar informaci\u00f3n al usuario","text":"<p>Es necesario a\u00f1adir tambi\u00e9n en <code>Info.plist</code> una cadena asociada a la clave <code>NSLocationWhenInUseUsageDescription</code>. Esta clave tiene la descripci\u00f3n en Xcode <code>Privacy - Location When in Use Usage Description</code>.</p> <p> </p> <p>Se solicita autorizaci\u00f3n al usuario llamando al m\u00e9todo <code>request\u200bWhen\u200bIn\u200bUse\u200bAuthorization()</code> o <code>requestAlwaysAuthorization()</code> del objeto <code>CLLocationManager</code>.</p> <p>La cadena se mostrar\u00e1 como subt\u00edtulo en el di\u00e1logo en el que se solicita al usuario la autorizaci\u00f3n.</p> <p> </p>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clase-cllocationmanager","title":"Clase <code>CLLocationManager</code>","text":"<p>Se debe crear una instancia de la clase <code>CLLocation\u200bManager</code> necesita mantener una referencia a esta instancia que han terminado todas las tareas en las que participa.</p> <p>Debido a que las tareas de gesti\u00f3n de localizaci\u00f3n se ejecutan as\u00edncronamente, no debemos almacenar una referencia al location manager en una variable local.</p> <p>La clase <code>AppDelegate</code> tambi\u00e9n puede funcionar como <code>CLLocationManagerDelegate</code>. Inicializamos ah\u00ed el <code>CLLocationManager</code>.</p> <p>En el m\u00e9todo <code>didFinishLaunchingWithOptions</code> podemos actualizar el gestor de localizaci\u00f3n:</p> <ul> <li>Inicializamos el delegado del gestor de localizaci\u00f3n.</li> <li>Solicitamos permiso al usuario de que la app va a usar los servicios de localizaci\u00f3n invocando al m\u00e9todo <code>requestWhenInUseAuthorization()</code></li> </ul> <p>Se debe configurar la precisi\u00f3n de la localizaci\u00f3n, actualizando la propiedad <code>desiredAccuracy</code> del gestor de localizaci\u00f3n, asign\u00e1ndole el valor en metros de la precisi\u00f3n deseada. Cuanto mayor sea la precisi\u00f3n deseada, mayor ser\u00e1 el consumo de bater\u00eda del dispositivo.</p> <p>Despu\u00e9s se debe llamar al m\u00e9todo <code>startUpdatingLocation()</code>.</p> <p>Ejemplo de c\u00f3digo:</p> <pre><code>import UIKit\nimport CoreLocation\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate, CLLocationManagerDelegate {\n\n    var window: UIWindow?\n    let locationManager = CLLocationManager()\n\n    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {\n        // Override point for customization after application launch.\n        locationManager.delegate = self\n        locationManager.requestWhenInUseAuthorization()\n        locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters\n        locationManager.startUpdatingLocation()\n        return true\n    }\n\n    ...\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#monitorizacion-de-la-localizacion","title":"Monitorizaci\u00f3n de la localizaci\u00f3n","text":"<p>Cuando suceda un cambio en localizaci\u00f3n se notificar\u00e1 al delegado llamando a su m\u00e9todo <code>didUpdateLocations</code> pas\u00e1ndole un array de localizaciones (objetos <code>CLLocation</code>):</p> <pre><code>func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n   // C\u00f3digo para gestionar las localizaciones\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#clase-cllocation","title":"Clase <code>CLLocation</code>","text":"<p>La clase <code>CLLocation</code> permite representar una posici\u00f3n outdoor o indoor y el instante de tiempo asociado a ella.</p> <p>Atributos:</p> <ul> <li><code>coordinate</code></li> <li><code>altitude</code></li> <li><code>floor</code></li> <li><code>horizontalAccuracy</code></li> <li><code>verticalAccuracy</code></li> <li><code>speed</code></li> <li><code>course</code></li> <li><code>timestamp</code></li> <li><code>description</code></li> </ul>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#activacion-de-la-localizacion-en-el-mapa","title":"Activaci\u00f3n de la localizaci\u00f3n en el mapa","text":"<p>Una vez activado el servicio de localizaci\u00f3n se puede visualizar la localizaci\u00f3n en el mapa obteniendo el <code>MKUserTrackingBarButtonItem</code> y a\u00f1adi\u00e9ndolo a la barra de navegaci\u00f3n.</p> <p>No hace falta llamar a <code>startUpdatingLocation()</code>.</p> <p>Se puede hacer en el <code>ViewController</code> que contiene el mapa:</p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n    let userTrackingButton = MKUserTrackingBarButtonItem(mapView: mapView)\n    self.navigationItem.leftBarButtonItem = userTrackingButton\n}\n</code></pre>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#prueba-de-la-localizacion-en-el-simulador","title":"Prueba de la localizaci\u00f3n en el simulador","text":"<p>Es posible probar los servicios de localizaci\u00f3n desde el simulador. Pare ello se debe seleccionar la simulaci\u00f3n del movimiento y localizaci\u00f3n del dispositivo en Debug &gt; Location y escoger una de las siguientes opciones:</p> <ul> <li>Ninguna (se desactiva la localizadi\u00f3n)</li> <li>Custom (se puede definir una localizaci\u00f3n)</li> <li>Apple (localizaci\u00f3n de Apple en San Francisco)</li> <li>City Bicycle Ride (Simulaci\u00f3n de un paseo en bicicleta)</li> <li>City Run (Simulaci\u00f3n de una carrera por la ciudad)</li> <li>Freeway Ride (Simulaci\u00f3n de un recorrido en coche)</li> </ul>"},{"location":"teoria/mapas-localizacion/mapas-localizacion.html#referencias","title":"Referencias","text":"<ul> <li>Recursos sobre mapas y localizaci\u00f3n</li> <li>Location and maps programming guide</li> <li>Map Kit Framework Reference</li> <li>Core Location Framework Reference</li> <li>Converting a User's Location to a Descriptive Placemark</li> <li>Converting Between Coordinates and User-Friendly Place Names</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html","title":"Notificaciones","text":"<p>En esta sesi\u00f3n veremos la forma de crear, enviar y recibir notificaciones locales y remotas (push) usando el User Notifications Framework de iOS.</p>"},{"location":"teoria/notificaciones/notificaciones.html#introduccion","title":"Introducci\u00f3n","text":"<p>En iOS s\u00f3lo una \u00fanica aplicaci\u00f3n puede estar activa en un momento dado. Sin embargo, en muchas ocasiones las apps operan en un entorno basado en el tiempo o interconectado en el que es necesario avisar al usuario cuando sucede alg\u00fan evento. </p> <p>Las notificaciones locales y remotas permiten a estas apps notificar a sus usuarios cuando ocurre alg\u00fan suceso de su inter\u00e9s.</p> <p>Todo el API para gestionar las notificaciones se unifica en iOS 10 en el User Notifications Framework y en el User Notifications UI Framework Reference.</p> <p>Adem\u00e1s de los usos comentados, las notificaciones se utilizan tambi\u00e9n para la comunicaci\u00f3n entre nuestra app y el reci\u00e9n introducido Apple Watch. Se puede consultar la p\u00e1gina de recursos de Apple sobre el WatchOS Apps para m\u00e1s informaci\u00f3n.</p> <p></p> <p>En la sesi\u00f3n de hoy vamos a ver la \u00faltima versi\u00f3n del API de notificaciones, introducida en iOS 11.</p>"},{"location":"teoria/notificaciones/notificaciones.html#apariencia-de-las-notificaciones","title":"Apariencia de las notificaciones","text":"<p>Tanto las notificaciones locales como las remotas pueden aparecer como:</p> <ul> <li>Un aviso (alert) o tira (banner) en la parte superior de la pantalla. Los avisos obligan al usuario a realizar una interacci\u00f3n, las tiras aparecen y desaparecen.</li> </ul> <p></p> <ul> <li>Un globo (badge) en el icono de la app.</li> </ul> <p></p> <ul> <li>Un sonido que acompa\u00f1a la alerta, banner o badge.</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#donde-aparecen-las-notificaciones","title":"D\u00f3nde aparecen las notificaciones","text":"<p>Dependiendo de si el dispositivo est\u00e1 en uso o bloqueado, las notificaciones se comportan de distinta forma.</p> <p>Si el dispositivo est\u00e1 en uso, las notificaciones aparece en la parte superior.</p> <p> </p> <p>Si el dispositivo est\u00e1 bloqueado aparecen en la pantalla de bloqueo.</p> <p> </p> <p>En cualquier caso se guardan en el centro de notificaciones (se abre deslizando hacia abajo desde la parte superior de la pantalla).</p> <p> </p> <p>El usuario puede configurar la aceptaci\u00f3n de notificaciones y su apariencia en los ajustes (Ajustes &gt; Notificaciones).</p>"},{"location":"teoria/notificaciones/notificaciones.html#interaccion-en-las-notificaciones","title":"Interacci\u00f3n en las notificaciones","text":"<p>Cuando se recibe una notificaci\u00f3n, el usuario puede ignorarla, y se guarda en el centro de notificaciones.</p> <p>O puede interactuar con ella, despleg\u00e1ndola y seleccionando una de las opciones est\u00e1ndar (Abrir, Borrar o Ver):</p> <p></p> <ul> <li>Con la opci\u00f3n Abrir se pasa a primer plano la app a la que   corresponde la notificaci\u00f3n.</li> <li>Con la opci\u00f3n Borrar se borra la notificaci\u00f3n.</li> <li>Con la opci\u00f3n Ver se muestra completamente la notificaci\u00f3n y el   usuario puede seleccionar una de las acciones incluidas en ella. Con   el User Notifications UI Framework es posible a\u00f1adir im\u00e1genes,   audio, v\u00eddeo e interfaces de usuario a las notificaciones y permitir   al usuario interaccionar en la propia notificaci\u00f3n sin abrir la app.</li> </ul> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-locales","title":"Notificaciones locales","text":"<p>Las notificaciones remotas y locales satisfacen distintas necesidades de dise\u00f1o.</p> <p>Una notificaci\u00f3n local es planificada y enviada por la propia app, cuando est\u00e1 en funcionamiento o cuando est\u00e1 en background recogiendo datos de un servidor y recibe alguna informaci\u00f3n interesante.</p> <p></p> <p>Dos ejemplos de uso:</p> <ul> <li> <p>En una app que gestiona una lista de tareas por hacer, en la que   cada \u00edtem tiene una fecha y hora en el que debe ser completado.</p> </li> <li> <p>En una app que recibe en background informaci\u00f3n de cotizaciones en   bolsa y en la que hay un cambio considerable en la cotizaci\u00f3n de una   empresa que el usuario ha marcado.</p> </li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-remotas","title":"Notificaciones remotas","text":"<p>Una notificaci\u00f3n remota, tambi\u00e9n llamada notificaci\u00f3n push, llega del exterior del dispositivo. Se origina en un servidor remoto gestionado por el desarrollador de la app (denominado proveedor de la aplicaci\u00f3n) y se env\u00eda al dispositivo del usuario a trav\u00e9s del Apple Push Notification service (APNs).</p> <p></p> <p>Dos ejemplos de uso:</p> <ul> <li> <p>En una aplicaci\u00f3n de mensajer\u00eda (estilo WhatsApp) se notifica cuando   el usuario recibe un nuevo mensaje.</p> </li> <li> <p>En un reproductor de podcasts el servidor avisa de que hay un nuevo   episodio disponible para ser reproducido.</p> </li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#para-que-se-usan-las-notificaciones","title":"Para qu\u00e9 se usan las notificaciones","text":"<p>Las notificaciones locales se usan principalmente para gestionar alarmas, recordatorios y eventos de una forma sencilla, sin tener que usar un API m\u00e1s complicada como el EventKit Framework que conlleva el uso de apps como Calendario, Alarmas o Recordatorios.</p> <p>Las notificaciones remotas se utilizan para:</p> <ul> <li>Avisar al usuario de que han sucedido determinados eventos.</li> <li>Notificar a la app para que descargue contenido nuevo para que   est\u00e9 disponible la pr\u00f3xima vez que el usuario la utilice.</li> </ul> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#notification-service-app-extensions","title":"Notification service app extensions","text":"<p>Las app extensions de tipo notification service son extensiones que permiten modificar el contenido de las notificaciones remotas antes de ser entregadas al usuario.</p> <p>Por ejemplo, se pueden usar para:</p> <ul> <li>Implementar encriptaci\u00f3n end-to-end de las notificaciones.</li> <li>Modificar el contenido de la notificaci\u00f3n, adapt\u00e1ndolo a alg\u00fan   contexto modificado en la app.</li> <li>Descargar del servidor im\u00e1genes o media adicionales.</li> </ul> <p>Las veremos m\u00e1s adelante, en la sesi\u00f3n dedicada a las extensiones.</p>"},{"location":"teoria/notificaciones/notificaciones.html#ciclo-de-vida-de-la-app","title":"Ciclo de vida de la app","text":"<p>Si pulsamos en una notificaci\u00f3n y la app est\u00e1 en segundo plano no ejecut\u00e1ndose, la app vuelve a primer plano.</p> <p>Veremos que al volver a primer plano la app se ejecuta una funci\u00f3n de callback asociada a la notificaci\u00f3n, por lo que podremos modificar la interfaz de usuario para adecuarla a la notificaci\u00f3n que ha pulsado el usuario (por ejemplo, si se trata de una app como Twitter, ir al tweet correspondiente a la notificaci\u00f3n).</p> <p></p> <p>Estados del ciclo de vida de la app</p> Estado Descripci\u00f3n No corriendo La app no ha sido lanzada o fue terminada por el usuario o por el sistema. Inactiva La app est\u00e1 corriendo en primer plano pero no est\u00e1 recibiendo eventos (puede estar ejecutando c\u00f3digo, sin embargo). Una app permanece en este estado brevemente, mientras realiza una transici\u00f3n a otro estado. Activa La app est\u00e1 corriendo en primer plano y recibiendo eventos. Background La app est\u00e1 ejecutando c\u00f3digo pero no es visible en pantalla. Cuando el usuario sale de una app, el sistema mueve la app al estado de background antes de suspenderla. En otros momentos, el sistema puede lanzar una aplicaci\u00f3n en background (o despertar una app suspendida) y darle tiempo para manejar ciertas tareas espec\u00edficas. Por ejemplo, el sistema puede despertar una app para que procese descargas en background, o responda a notificaciones remotas. Una app en estado background debe hacer el m\u00ednimo trabajo posible y devolver r\u00e1pidamente el control al sistema. Suspendida La app est\u00e1 en memoria pero no ejecuta c\u00f3digo. El sistema suspende apps que est\u00e1n en background y no tienen tareas pendientes que completar. El sistema puede eliminar apps suspendidas en cualquier momento sin despertarlas, para hacer sitio para otras apps."},{"location":"teoria/notificaciones/notificaciones.html#api-de-notificaciones","title":"API de notificaciones","text":"<p>A partir de iOS 10 se unifican todas las funciones en el framework   UserNotifications.  </p> <p>Las clases y protocolos de ese framework permiten:</p> <ul> <li>Mismo c\u00f3digo para notificaciones locales y remotas</li> <li>M\u00e9todos delegados simplificados</li> <li>Mejor gesti\u00f3n de las notificaciones</li> <li>Opci\u00f3n para presentar la notificaci\u00f3n en el app</li> <li>Planificaci\u00f3n y manejo de notificaciones en extensiones</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#unusernotificationcenter","title":"<code>UNUserNotificationCenter</code>","text":"<p>La clase <code>UNUserNotificationCenter</code> es la clase principal de UserNotifications Framework. Define un singleton  que es el objeto encargado de planificar y gestionar todo lo relacionado con notificaciones.</p> <p>Este objeto es el que se debe utilizar para todos los siguientes tipos de tareas:</p> <ul> <li>Pedir autorizaci\u00f3n para mostrar las notificaciones.</li> <li>Declarar los tipos de notificaci\u00f3n y las acciones que soporta la app.</li> <li>Planificar el env\u00edo de notificaciones a la app.</li> <li>Gestionar notificaciones espec\u00edficas de la app mostradas en el Centro de Notificaciones.</li> <li>Obtener los ajustes relacionados con notificaciones de la app.</li> <li>Contener un delegado en el que se define la funci\u00f3n de callback a   la que el sistema llama cuando el usuario activa la notificaci\u00f3n.</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#notifications-ui-framework","title":"Notifications UI Framework","text":"<p>Es posible tambi\u00e9n incluir en la notificaci\u00f3n animaciones y gr\u00e1ficos din\u00e1micos usando el nuevo framework Notifications UI Framework.</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#preparacion-de-las-notificaciones","title":"Preparaci\u00f3n de las notificaciones","text":""},{"location":"teoria/notificaciones/notificaciones.html#registro-de-los-tipos-de-notificacion","title":"Registro de los tipos de notificaci\u00f3n","text":"<p>Las apps que usan notificaciones locales o remotas deben registrar los tipos de notificaciones que intentan enviar al usuario. Lo normal es hacerlo antes de que la aplicaci\u00f3n termine de lanzarse, en el m\u00e9todo <code>application:didFinishLaunchingWithOptions:</code> del delegado de la aplicaci\u00f3n.</p> <p>El usuario debe aceptar el tipo de notificaci\u00f3n: globos, alertas o sonidos. Inicialmente le aparecer\u00e1 una alerta en el que permite aceptar o rechazar todos los tipos.</p> <p>Despu\u00e9s en cualquier momento puede modificar esta aceptaci\u00f3n en los ajustes de la aplicaci\u00f3n (Ajustes &gt; Notificaciones).</p> <p>Por ejemplo, en el siguiente c\u00f3digo se solicita autorizaci\u00f3n para mostrar avisos, sonidos y globos:</p> <pre><code>func application(_ application: UIApplication, \n                 didFinishLaunchingWithOptions launchOptions: \n                     [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {\n    UNUserNotificationCenter.current()\n        .requestAuthorization(options: [.alert, .sound, .badge])\n        { (granted, error) in print(granted)}\n    return true\n}\n</code></pre> <p>Se utiliza el m\u00e9todo <code>requestAuthorization(options:completionHandler:)</code> del singleton <code>UserNotificationCenter</code> (accesible con el m\u00e9todo de  tipo   <code>current()</code>).</p> <p>Se pasa como par\u00e1metro los tipos de notificaci\u00f3n que solicitamos usar (tira, sonido o aviso) y un completion handler que se ejecuta tras la aceptaci\u00f3n o negaci\u00f3n de los servicios por parte del usuario.</p> <p>La primera vez que la app solicita autorizaci\u00f3n, aparece un aviso y el usuario puede aceptar o denegar la autorizaci\u00f3n.</p> <p></p> <p>Despu\u00e9s de la petici\u00f3n inicial, el sistema recuerda la respuesta del usuario y la devuelve en cualquier nueva petici\u00f3n.</p>"},{"location":"teoria/notificaciones/notificaciones.html#obtener-los-ajustes-definidos-por-el-usuario","title":"Obtener los ajustes definidos por el usuario","text":"<p>El m\u00e9todo <code>getNotificationSettings(completionHandler:)</code> pide al sistema los ajustes y ejecuta as\u00edncronamente un completion handler que recibe un objeto <code>UNNotificationSettings</code> como par\u00e1metro.</p> <pre><code>func applicationWillEnterForeground(_ application: UIApplication) {\n    print(\"Voy a pedir los settigs\")\n    UNUserNotificationCenter.current().\n        getNotificationSettings(completionHandler:\n            {(settings: UNNotificationSettings) in\n                if (settings.alertSetting == UNNotificationSetting.enabled) {\n                    print(\"Alert enabled\")\n                } else {\n                    print(\"Alert not enabled\")\n                }\n                if (settings.badgeSetting == UNNotificationSetting.enabled) {\n                    print(\"Badge enabled\")\n                } else {\n                    print(\"Badge not enabled\")\n                }})\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-locales_1","title":"Notificaciones locales","text":"<p>Las notificaciones locales son creadas por la propia app y el sistema es responsable de lanzarlas en la fecha y hora planificada. La app no tiene que estar en marcha para que esto suceda.</p> <p>Con una notificaci\u00f3n local se puede hacer lo mismo que con una remota: mostrar alertas, ejecutar sonidos o a\u00f1adir globos al icono del app.</p> <p>Se usan principalmente en apps con conductas basadas en temporizadores y en apps sencillas de calendarios o de listas de to-do. Una app que est\u00e1 ejecut\u00e1ndose en background tambi\u00e9n puede planificar una notificaci\u00f3n para informar al usuario de que ha llegado un mensaje, un chat o se ha actualizado alg\u00fan estado.</p>"},{"location":"teoria/notificaciones/notificaciones.html#creacion-de-notificaciones","title":"Creaci\u00f3n de notificaciones","text":"<p>La creaci\u00f3n de una nueva notificaci\u00f3n se realiza con la clase   <code>UNNotificationRequest</code>,   indicando los siguientes elementos:</p> <ul> <li>Identificador (<code>identifier: String</code>) que identifica de forma \u00fanica la petici\u00f3n de notificaci\u00f3n.</li> <li>Contenido de la notificaci\u00f3n (<code>content: UNNotificationContent</code>)</li> <li>Condiciones que disparan la notificaci\u00f3n (<code>trigger: UNNotificationTrigger?</code>)</li> </ul> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#contenido-de-la-notificacion","title":"Contenido de la notificaci\u00f3n","text":"<p>El contenido de la notificaci\u00f3n se define con la clase UNMutableNotificationContent. Podemos actualizar sus propiedades para especificar:</p> <ul> <li><code>title: String</code>: Breve descripci\u00f3n de la raz\u00f3n del aviso</li> <li><code>subtitle: String</code>: Descripci\u00f3n secundaria </li> <li><code>body: String</code>: El mensaje mostrado en el aviso </li> <li><code>badge: NSNumber?</code>: El n\u00famero a mostrar en el globo de la app</li> <li><code>sound: UNNotificationSound?</code>: El sonido cuando se entrega la notificaci\u00f3n </li> <li><code>launchImageName: String</code>: El nombre de la imagen de lanzamiento    a mostrar cuando la app se lanza en respuesta a la notificaci\u00f3n</li> <li><code>var userInfo: [AnyHashable : Any]</code>: Un diccionario de informaci\u00f3n asociada con la notificaci\u00f3n</li> <li><code>var attachments: [UNNotificationAttachment]</code>: Un array de adjuntos a mostrar con la notificaci\u00f3n</li> </ul> <p>Por ejemplo, la siguiente notificaci\u00f3n:</p> <p></p> <p>se especifica con el siguiente c\u00f3digo:</p> <pre><code>let content = UNMutableNotificationContent()\ncontent.title = \"Introduction to Notifications\"\ncontent.subtitle = \"Session 707\"\ncontent.body = \"Woah! These new notifications look amazing! Don\u2019t you agree?\"\ncontent.badge = 1\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#media-attachments","title":"Media attachments","text":"<p>Es posible adjuntar a una notificaci\u00f3n im\u00e1genes, v\u00eddeo o audio. Los attachments deben ser ficheros en el disco y el formato del fichero debe ser uno de los tipos soportados:</p> <ul> <li>Audio: MP3, MPEG4</li> <li>Imagen: JPEG, GIF, PNG</li> <li>V\u00eddeo: MPEG, MPEG2, MPEG4, AVI</li> </ul> <p>Se debe crear un objeto de tipo   <code>UNNotificationAttachment</code>.</p> <p></p> <p>Para crear el attachment deberemos proporcionar la URL que nos da acceso al fichero del recurso a adjuntar. Por ejemplo, en caso de querer incluir una imagen empaquetada en nuestra aplicaci\u00f3n, obtenemos en primer lugar su URL dentro del bundle, creamos el objeto <code>UNNotificationAttachment</code> a partir de la URL, y por \u00faltimo lo a\u00f1adimos al contenido de nuestra notificaci\u00f3n, como se muestra a continuaci\u00f3n:</p> <pre><code>do {\n    if let url = Bundle.main.url(forResource: \"foto\", withExtension: \"png\") {\n        let attachment = try UNNotificationAttachment(identifier: \"imagen\", url: url)\n        content.attachments = [attachment]\n    }\n} catch {\n    print(\"Error al crear attachment\")\n}\n</code></pre> <p>Si queremos incluir una imagen que se encuentra en un objeto de tipo <code>UIImage</code>, pero que no est\u00e1 almacenada en forma de fichero, podemos crear una extensi\u00f3n de <code>UNNotificationAttachment</code> como la siguiente que se encargue de almacenar la imagen en un fichero temporal y nos de su URL:</p> <pre><code>extension UNNotificationAttachment {\n    static func create(identifier: String, image: UIImage, options: [NSObject : AnyObject]?) -&gt; UNNotificationAttachment? {\n        let fileManager = FileManager.default\n        let tmpSubFolderName = ProcessInfo.processInfo.globallyUniqueString\n        let tmpSubFolderURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(tmpSubFolderName, isDirectory: true)\n        do {\n            try fileManager.createDirectory(at: tmpSubFolderURL, withIntermediateDirectories: true, attributes: nil)\n            let imageFileIdentifier = identifier+\".png\"\n            let fileURL = tmpSubFolderURL.appendingPathComponent(imageFileIdentifier)\n            guard let imageData = image.pngData() else {\n                return nil\n            }\n            try imageData.write(to: fileURL)\n            let imageAttachment = try UNNotificationAttachment.init(identifier: imageFileIdentifier, url: fileURL, options: options)\n            return imageAttachment\n        } catch {\n            print(\"error \" + error.localizedDescription)\n        }\n        return nil\n    }\n}\n</code></pre> <p>Una vez definida la extensi\u00f3n, podemos utilizar el nuevo m\u00e9todo definido para crear el attachment e incluirlo en la notificaci\u00f3n:</p> <pre><code>if let attachment = UNNotificationAttachment.\n                           create(identifier: \"prueba\",\n                                  image: UIImage(named: \"gatito.png\")!,\n                                  options: nil) {\n   content.attachments = [attachment]\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#condiciones-de-disparo-de-la-notificacion","title":"Condiciones de disparo de la notificaci\u00f3n","text":"<p>Otro de los elementos que hay que indicar en una notificaci\u00f3n local son las condiciones de disparo.</p> <p></p> <ul> <li>Intervalo de tiempo: dentro determinado intervalo de   tiempo (\"dentro de 2 minutos a partir de ahora\"). Repeticiones en un intervalo determinado (\"repite la   notificaci\u00f3n cada hora a partir de ahora\").</li> <li>Calendario: en una determinada fecha (\"a las 8:00 del d\u00eda 20 de   abril\") y tambi\u00e9n peri\u00f3dicos (\"cada lunes a las 18:00\").</li> <li>Localizaci\u00f3n: cuando entre o salga de una determinada regi\u00f3n   geogr\u00e1fica (\"cuando salga de casa\" o \"cuando llegue al supermercado\").</li> </ul> <p>Para codificar las condiciones de disparo debemos usar una de las subclases de la clase abstracta <code>UNNotificationTrigger</code>:</p> <ul> <li> <p><code>UNTimeIntervalNotificationTrigger</code>: Para entregar una   notificaci\u00f3n local en cierto momento relativo a al momento   actual. Se debe especificar el n\u00famero de segundos que debe pasar   antes de que la notificaci\u00f3n se lance. Tambi\u00e9n se puede definir   un intervalo de repetici\u00f3n.</p> <pre><code>// Fire in 30 minutes (60 seconds times 30)\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: (30*60), repeats: false)\n</code></pre> </li> <li> <p><code>UNCalendarNotificationTrigger</code>: Para especificar una fecha y   hora concreta en la que lanzar una notificaci\u00f3n. Por ejemplo,   para crear un trigger que lanza notificaciones todas las   ma\u00f1anas a las 8:30:</p> <pre><code>var date = DateComponents()\ndate.hour = 8\ndate.minute = 30 \nlet trigger = UNCalendarNotificationTrigger(dateMatching: date, repeats: true)\n</code></pre> </li> <li> <p><code>UNLocationNotificationTrigger</code>: Para entregar una notificaci\u00f3n   cuando el dispositivo entra o abandona una zona geogr\u00e1fica   espec\u00edfica.</p> <pre><code>let center = CLLocationCoordinate2D(latitude: 37.335400, longitude: -122.009201)\nlet region = CLCircularRegion(center: center, radius: 2000.0, identifier: \"Headquarters\")\nregion.notifyOnEntry = true\nregion.notifyOnExit = false\nlet trigger = UNLocationNotificationTrigger(region: region, repeats: false)\n</code></pre> </li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#creacion-de-la-notificacion-local","title":"Creaci\u00f3n de la notificaci\u00f3n local","text":"<p>Una vez definido el contenido y las condiciones de disparo se puede crear la notificaci\u00f3n local usando el m\u00e9todo <code>add</code> del centro de notificaciones compartido:</p> <pre><code>let content = UNMutableNotificationContent()\ncontent.title = \"Introducci\u00f3n a Notificaciones\"\ncontent.body = \"Hablemos sobre notificaciones!\"\ncontent.sound = UNNotificationSound.default\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false)\nlet requestIdentifier = \"peticionEjemplo\"\nlet request = UNNotificationRequest(identifier: requestIdentifier,\n                                    content: content,\n                                    trigger: trigger)\nUNUserNotificationCenter.current().add(request) {\n            (error) in print (\"Error \\(String(describing: error))\")}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#demo","title":"Demo","text":"<p>Vamos a probar el c\u00f3digo visto hasta ahora en una app ejemplo.</p>"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-app-notificaciones","title":"Ejemplo de app: <code>Notificaciones</code>","text":"<p>Descargamos la app Notificaciones en la que podemos lanzar notificaciones locales.</p> <p>Las notificaciones locales se pueden probar en el simulador.</p> <p></p> <p></p> <p></p> <ul> <li>Mostramos el funcionamiento de la app y los mensajes que aparecen   por la salida est\u00e1ndar.</li> <li>Mostramos el c\u00f3digo del registro de notificaciones en el m\u00e9todo   <code>application(_:didFinishLaunchingWithOptions:)</code> de la clase <code>AppDelegate</code>.</li> <li>Mostramos el c\u00f3digo de registro y creaci\u00f3n de la notificaci\u00f3n en el mismo   m\u00e9todo.</li> <li>Mostramos el c\u00f3digo de los m\u00e9todos manejadores del ciclo de vida de   la app y el de obtenci\u00f3n de los settings de notificaciones.</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#acciones","title":"Acciones","text":"<p>Es posible incorporar en la notificaci\u00f3n distintos tipos de acciones:</p> <ul> <li>Botones con t\u00edtulos customizables</li> <li>Entrada de texto</li> </ul> <p>Las acciones se crean con la clase <code>UNNotificationAction</code>.</p> <p>Para conseguir una entrada de texto hay que crear un objeto de tipo <code>UNTextInputNotificationAction</code>.</p> <p>El conjunto de acciones de una notificaci\u00f3n deben agruparse en una categor\u00eda <code>UNNotificationCategory</code> que se registra en el <code>UNUserNotificationCenter</code> asociada a un identificador. Una vez creada la categor\u00eda con el conjunto de acciones podemos crear una notificaci\u00f3n que contenga estas acciones inicializando la propiedad <code>categoryIdentifier</code> de la notificaci\u00f3n con la cadena apropiada.</p> <p>La acci\u00f3n en la que el usuario pulsa en la notificaci\u00f3n se denomina acci\u00f3n por defecto, y es la cadena: <code>com.apple.UNNotificationDefaultActionIdentifier</code>.</p>"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-codigo-de-creacion-de-una-accion","title":"Ejemplo de c\u00f3digo de creaci\u00f3n de una acci\u00f3n","text":"<p>Para crear las acciones y asociarlas a una categor\u00eda:</p> <pre><code>let action1 = UNNotificationAction(identifier:\"acepto\", \n                                   title: \"Acepto\", options: [])\nlet action2 = UNNotificationAction(identifier:\"otro\", \n                                   title: \"Otro d\u00eda\", options: [])\n// Acci\u00f3n con entrada de texto\nlet action3 = UNTextInputNotificationAction(identifier: \"mensaje\", \n                                   title: \"Mensaje\", options: [],\n                                   textInputButtonTitle: \"Enviar\",\n                                   textInputPlaceholder: \"Comentario\")\nlet category = UNNotificationCategory(identifier: \"invitacion\", \n                                   actions: [action1, action2, action3], \n                                   intentIdentifiers: [], options: [])\nUNUserNotificationCenter.current().setNotificationCategories([category])\n</code></pre> <p>Para asignar las acciones a la notificaci\u00f3n se asigna el identificador de la categor\u00eda.</p> <pre><code>content.categoryIdentifier = \"invitacion\"\n</code></pre> <p>La notificaci\u00f3n creada tiene el siguiente aspecto:</p> <p> </p>"},{"location":"teoria/notificaciones/notificaciones.html#manejo-de-notificaciones","title":"Manejo de notificaciones","text":"<p>Una vez que el usuario ha pulsado una acci\u00f3n de la notificaci\u00f3n o la ha abierto nuestra app debe gestionar esa acci\u00f3n. Es lo que se denomina manejo de la notificaci\u00f3n. Para ello debemos implementar los m\u00e9todos del protocolo <code>UNUserNotificationCenterDelegate</code>.</p> <ul> <li> <p><code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>: se llama cuando la app est\u00e1 en segundo plano y el usuario pulsa la notificaci\u00f3n.</p> </li> <li> <p><code>userNotificationCenter(_:willPresent:withCompletionHandler:)</code>: se llama cuando la app est\u00e1 en primer plano y se recibe la notificaci\u00f3n. </p> </li> </ul> <p>Estos m\u00e9todos se suelen implementar en el propio <code>AppDelegate</code>, que cumple este protocolo. Y se debe asignar al centro de notificaciones en los m\u00e9todos <code>application(_:willFinishLaunchingWithOptions:)</code> o <code>application(_:didFinishLaunchingWithOptions:)</code>. Por ejemplo:</p> <pre><code>func application(_ application: UIApplication, \n                 didFinishLaunchingWithOptions launchOptions: \n                       [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {\n    ...\n    UNUserNotificationCenter.current().delegate = self\n    ...\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#app-en-segundo-plano","title":"App en segundo plano","text":"<p>Cuando la app est\u00e1 en segundo plano (en background) las notificaciones se reciben y muestran en el sistema.</p> <p>El usuario puede pulsar en la notificaci\u00f3n o interactuar con las acciones de la notificaci\u00f3n y pulsar una de ellas. En ambos casos se llama al m\u00e9todo mencionado anteriormente <code>userNotificationCenter(_:didReceive response:withCompletionHandler:)</code> pasando en la variable <code>response</code> la informaci\u00f3n de la opci\u00f3n seleccionada por el usuario. Esta variable es del tipo <code>UNNotificationResponse</code> y en el atributo <code>actionIdentifier</code> lleva una cadena con la acci\u00f3n seleccionada por el usuario. Si el usuario ha pulsado directamente la notificaci\u00f3n para abrir la app, la cadena es <code>com.apple.UNNotificationDefaultActionIdentifier</code>.</p> <p>Si el usuario ha escrito un mensaje en la acci\u00f3n de la notificaci\u00f3n, la respuesta que llega es del tipo <code>UNTextInputNotificationResponse</code> y podemos acceder al texto del usuario en su atributo <code>userText</code>.</p> <p>Podemos recuperar informaci\u00f3n completa contenida en la notificaci\u00f3n (un objeto de tipo <code>UNNotificationRequest</code>) accediendo al atributo <code>notification.request</code> de la respuesta recibida. Si se ha a\u00f1adido informaci\u00f3n asociada a la notificaci\u00f3n la podemos obtener en el atributo <code>userInfo</code> (<code>response.notification.request.content.userInfo</code>).</p> <p>Por \u00faltimo, tambi\u00e9n podemos acceder al view controller ra\u00edz de la aplicaci\u00f3n para modificar alg\u00fan elemento de la interfaz de usuario relacionada con la notificaci\u00f3n que ha pulsado el usuario (ver el ejemplo al final del c\u00f3digo).</p> <pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, \n                            didReceive response: UNNotificationResponse, \n                            withCompletionHandler completionHandler: @escaping () -&gt; Void) {\n    print(\"En userNotificationCenter didReceive response\")\n    if let textInput = response as? UNTextInputNotificationResponse {\n        print(\"Repuesta del usuario: \\(textInput.userText)\")\n    } else {\n        print(\"Acci\u00f3n escogida: \\(response.actionIdentifier)\")\n    }\n    let userInfo = response.notification.request.content.userInfo\n    let mensaje = userInfo[\"Mensaje\"] as! String\n    print(\"Mensaje: \\(mensaje)\")\n\n    // Actualizamos la variables de estado relacionada con la notificaci\u00f3n\n    // y modificamos la interfaz de usuario accediendo al rootViewController\n\n    vecesPulsadaNotificacion += 1\n    let viewController = self.window?.rootViewController as! ViewController\n    viewController.actualiza(numVecesPulsadaNotificacion: vecesPulsadaNotificacion)\n    completionHandler()\n}\n</code></pre> <p>Si el usuario ha seleccionado una acci\u00f3n la aplicaci\u00f3n no pasa a primer plano. Sin embargo, si el usuario ha decidido abrir la notificaci\u00f3n, la aplicaci\u00f3n pasa a primer plano, ejecut\u00e1ndose el m\u00e9todo de ciclo de vida <code>applicationWillEnterForeground</code> del <code>UIApplicationDelegate</code>.</p> <p>Si la notificaci\u00f3n recibida es una notificaci\u00f3n remota se llama al m\u00e9todo <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> del <code>UIApplicationDelegate</code> (lo veremos m\u00e1s adelante).</p>"},{"location":"teoria/notificaciones/notificaciones.html#app-en-primer-plano","title":"App en primer plano","text":"<p>Para trabajar con la notificaci\u00f3n cuando la app est\u00e1 en primer plano se define en el protocolo la funci\u00f3n <code>userNotificationCenter(_:willPresent:withCompletionHandler:)</code>.</p> <p>El sistema llama a esta funci\u00f3n cuando se recibe una notificaci\u00f3n y la app est\u00e1 en primer plano.</p> <p>Por defecto, la notificaci\u00f3n no se muestra al usuario. Si queremos que la notificaci\u00f3n aparezca debemos llamar al completionHandler pasando como par\u00e1metro un array con las opciones de visualizaci\u00f3n que deseamos.</p> <p>Un ejemplo de c\u00f3digo:</p> <pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter,\n                            willPresent notification: UNNotification,\n                            withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {\n    print(\"En userNotificationCenter willPresent notification\")\n    let userInfo = notification.request.content.userInfo\n    let mensaje = userInfo[\"Mensaje\"] as! String\n    print(\"Mensaje: \\(mensaje)\")\n    completionHandler([.alert, .sound])\n}\n</code></pre> <p>En el ejemplo anterior, al pasar al completionHandler un array que contiene <code>.alert</code>la notificaci\u00f3n se mostrar\u00e1 al usuario. El usuario podr\u00e1 interactuar con ella de la forma que hemos visto anteriormente.</p>"},{"location":"teoria/notificaciones/notificaciones.html#demo_1","title":"Demo","text":"<p>Probamos y examinamos el c\u00f3digo de la aplicaci\u00f3n de prueba que incluye acciones en la notificaci\u00f3n y que define las funciones de gesti\u00f3n de las notificaciones.</p> <p></p> <p>Probamos a seleccionar distintas acciones y comprobar qu\u00e9 mensaje aparece por la salida est\u00e1ndar:</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#notificaciones-remotas-push","title":"Notificaciones remotas (push)","text":""},{"location":"teoria/notificaciones/notificaciones.html#objetivos-de-las-notificaciones-remotas","title":"Objetivos de las notificaciones remotas","text":"<p>Una notificaci\u00f3n remota permite enviar informaci\u00f3n interesante relacionada con la app directamente al usuario. Para ello la app debe contar con un servicio que ser\u00e1 el responsable de enviar esa informaci\u00f3n.</p> <p>Por ejemplo, una app que sea un peri\u00f3dico puede tener un servicio que env\u00ede una notificaci\u00f3n al usuario cuando sucede una noticia relevante.</p> <p>Tambi\u00e9n es posible enviar una notificaci\u00f3n invisible que llega a la app para que descargue nueva informaci\u00f3n en background y la muestre instant\u00e1neamente la siguiente vez que el usuario acceda a la app. </p> <p>El env\u00edo de notificaciones se hace a trav\u00e9s del servicio de Apple APNs (Apple Push Notification service).</p> <p> </p>"},{"location":"teoria/notificaciones/notificaciones.html#arquitectura-de-las-notificaciones-remotas","title":"Arquitectura de las notificaciones remotas","text":"<p>El servicio Apple Push Notification service (APNs) es la pieza central de las notificaciones remotas. Es un servicio robusto y altamente eficiente para propagar informaci\u00f3n a dispositivos iOS y OS X.</p> <p></p> <p>Cada dispositivo establece una conexi\u00f3n acreditada y encriptada con el servicio y recibe notificaciones sobre esta conexi\u00f3n persistente.</p> <p>Si llega una notificaci\u00f3n para una app cuando el dispositivo est\u00e1 fuera de cobertura, el APNs guarda la notificaci\u00f3n hasta que el dispositivo vuelve a estar disponible.</p> <p>Las notificaciones se originan en servidores (proveedores) propios del desarrollador. Los proveedores se conectan con el APNs y reciben datos de sus apps clientes. Cuando llegan nuevos datos para un app, los proveedores preparan y env\u00edan notificaciones a trav\u00e9s de los canales al APNs, que se encarga de enviarlas a los dispositivos.</p>"},{"location":"teoria/notificaciones/notificaciones.html#arquitectura-de-seguridad","title":"Arquitectura de seguridad","text":"<p>No queremos que nuestras notificaciones (con datos personales) puedan aparecer en otros dispositivos.</p> <p></p> <p>El servicio de notificaciones remota de Apple (APNs) define unas condiciones de seguridad bastante estrictas tanto entre dispositivo y servicio como entre proveedor (nuestro servidor y el servicio.</p> <ul> <li>Seguridad en la conexi\u00f3n Proveedor-APNs<ul> <li>Basada en JWT (JSON web tokens) o basada en un certificado.</li> </ul> </li> <li>Seguridad en la conexi\u00f3n APNs-Dispositivo<ul> <li>Basada en un token de dispositivo (\u00fanico para cada dispositivo   y encriptado con su clave privada) que env\u00eda el APNs al   dispositivo y que debe estar presente en cada petici\u00f3n del   proveedor al APNs.</li> </ul> </li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#servidores-proveedores","title":"Servidores proveedores","text":"<p>Las notificaciones remotas se deben originar en un servidor proveedor nuestro que debe conectarse con el APNs usando la API definida por Apple basada en un protocolo HTTP/2 y TLS.</p> <p>Es posible montar un servidor propio usando librer\u00edas ya existentes. Por ejemplo, en Java existe la librer\u00eda Pushy. Es recomendable consultar la documentaci\u00f3n de Apple Setting Up a Remote Notification Server y Sending Notification Requests to APNs.</p> <p>La mayor\u00eda de servicios PaaS proporcionan conexiones con el APNs y librer\u00edas que facilitan el env\u00edo de notificaciones:</p> <ul> <li>Firebase Cloud Messaging for iOS</li> <li>Amazon Web Services</li> <li>Microsoft Azure</li> </ul> <p>Una opci\u00f3n sencilla, que usaremos en la pr\u00e1ctica, es lanzar la notificaci\u00f3n desde el terminal.</p> <p>En cualquier caso la conexi\u00f3n al APNs debe estar encriptada: o bien un certificado proporcionado por Apple o bien un token, usando JWT (JSON Web Token). Esto \u00faltimo es lo que haremos en la demostraci\u00f3n.</p> <ul> <li>Establishing a Certificate-Based Connection to APNs</li> <li>Establishing a Token-Based Connection to APNs</li> </ul> <p>Para la demostraci\u00f3n y la pr\u00e1ctica enviaremos la notificaci\u00f3n al APNs usando el terminal y una autenticaci\u00f3n con JWT. Cada notificaci\u00f3n se enviar\u00e1 junto con un JWT firmado con una clave privada generada en el portal de desarrollo.</p>"},{"location":"teoria/notificaciones/notificaciones.html#secuencia-de-registro-del-dispositivo","title":"Secuencia de registro del dispositivo","text":"<p>Sin considerar aspectos de seguridad y codificaci\u00f3n, los pasos que se siguen al registrarse un dispositivo con el m\u00e9todo de la clase <code>Application</code> registerForRemoteNotifications() son los siguientes:</p> <p></p> <ol> <li>El dispositivo establece una conexi\u00f3n SSL con el APNs.</li> <li>El APNs le env\u00eda un token \u00fanico asociado con el dispositivo.</li> <li>El dispositivo le env\u00eda el token al app.</li> <li>El app env\u00eda el token a su servidor (Provider) para que lo    utilice a partir de ese momento en cada petici\u00f3n de notificaci\u00f3n    realizada al APNs.</li> </ol>"},{"location":"teoria/notificaciones/notificaciones.html#token-del-dispositivo","title":"Token del dispositivo","text":"<p>Cada dispositivo iOS tiene un certificado y una clave privada criptogr\u00e1fica, proporcionada por el sistema operativo en la activaci\u00f3n inicial y almacenada en el llavero del dispositivo.</p> <p>Este certificado sirve para establecer una conexi\u00f3n segura basada en TLS con el APNs. Con la conexi\u00f3n TLS activa, las apps en el dispositivo pueden registrarse con APNs para recibir un token espec\u00edfico para recibir notificaciones remotas.</p> <p></p> <p>El APNs genera el token, que contiene la informaci\u00f3n del dispositivo, lo encripta utilizando una clave asociada al token y lo env\u00eda al dispositivo. El sistema entrega el token encriptado a la app, llamando al m\u00e9todo del delegado <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>.</p> <p>Una vez recibido el token, el app debe enviarlo al proveedor (en formato binario o hexadecimal) para que lo utilice para enviar notificaciones al dispositivo.</p> <p>Cuando el servidor env\u00eda una petici\u00f3n de notificaci\u00f3n al APNs, se debe incluir el token del dispositivo.</p> <p>El APNs desencripta el token para asegurarse de la validez de la petici\u00f3n y determina el dispositivo de destino.</p> <p>Si el APNs determina que el emisor y el receptor son leg\u00edtimos, env\u00eda la notificaci\u00f3n al dispositivo identificado.</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#contenido-de-la-notificacion_1","title":"Contenido de la notificaci\u00f3n","text":"<p>Una vez definido el mecanismo de seguridad en el env\u00edo de las notificaciones, veamos c\u00f3mo se define el contenido de la notificaci\u00f3n.</p> <p>El mensaje enviado al APNs se denomina payload y debe cumplir unas condiciones estrictas definidas en la documentaci\u00f3n de Apple. El tama\u00f1o m\u00e1ximo est\u00e1 limitado a 4096 bytes y debe tener el formato de un objeto JSON diccionario (parejas clave, valor).</p> <p>Un ejemplo en JSON:</p> <pre><code>{\n\"aps\" : {\n\"alert\" : {\n\"title\" : \"Introducci\u00f3n a las notificaciones\",\n\"subtitle\" : \"Sesi\u00f3n 707\",\n\"body\" : \"La nueva API de notificaciones es genial!!!\",\n\"category\" : \"mensaje\",\n},\n\"badge\" : 1\n},\n}\n</code></pre> <p>El diccionario debe contener otro diccionario identificado por la clave <code>aps</code>. Este diccionario contiene una o m\u00e1s propiedades que especifican los siguientes tipos de notificaci\u00f3n:     - Mensaje de alerta a mostrar al usuario     - Numero a a\u00f1adir en el globo del icono de la app     - Sonido a tocar</p> <p>El diccionario <code>aps</code> tambi\u00e9n puede tener la clave <code>content-available</code> con un valor de 1. Eso significa que la notificaci\u00f3n ser\u00e1 una notificaci\u00f3n silenciosa que har\u00e1 que el sistema despierte la app y la ponga en background para que pueda conectarse al servidor o hacer alguna tarea de background. En este caso es conveniente no mostrar al usuario ninguna notificaci\u00f3n. El contenido nuevo se ver\u00e1 la siguiente vez que se abra la app.</p> <p>El resto del diccionario contendr\u00e1 parejas clave-valor con informaci\u00f3n custom.</p> <p>La informaci\u00f3n JSON se convierte en un diccionario que se pasa como par\u00e1metro <code>userInfo</code> en el m\u00e9todo <code>didReceiveRemoteNotification</code> del delegado del app.</p> <p>Otros ejemplos de payload.</p> <p>N\u00famero en el badge y custom keys:</p> <pre><code>{\n\"aps\" : {\n\"alert\" : \"You got your emails.\",\n\"badge\" : 9,\n\"sound\" : \"bingbong.aiff\"\n},\n\"acme1\" : \"bar\",\n\"acme2\" : 42\n}\n</code></pre> <p>Notificaci\u00f3n silenciosa:</p> <pre><code>{\n\"aps\" : {\n\"content-available\" : 1\n},\n\"acme1\" : \"bar\",\n\"acme2\" : 42\n}\n</code></pre> <p>Notificaci\u00f3n con cadenas localizadas:</p> <pre><code>{\n\"aps\" : {\n\"alert\" : {\n\"loc-key\" : \"GAME_PLAY_REQUEST_FORMAT\",\n\"loc-args\" : [ \"Jenna\", \"Frank\"]\n},\n\"sound\" : \"chime.aiff\"\n},\n\"acme\" : \"foo\"\n}\n</code></pre> <p>Notificaci\u00f3n con acciones:</p> <pre><code>{\n\"aps\" : {\n\"alert\u201d : {\n         \u201cbody\u201d : \"Acme message received from Johnny Appleseed\u201d,\n\u201caction-loc-key\u201d : \u201cVIEW\u201d,\n\"actions\" : [\n{\n\u201cid\" : \u201cdelete\",\n\"title\" : \"Delete\"\n},\n{\n\u201cid\" : \u201creply-to\u201d,\n               \"loc-key\" : \u201cREPLYTO\u201d,\n               \"loc-args\" : [\u201cJane\"]\n}\n]\n}\n\"badge\" : 3,\n\"sound\" : \u201cchime.aiff\"\n   },\n   \"acme-account\" : \"jane.appleseed@apple.com\",\n   \"acme-message\" : \"message123456\"\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#gestion-de-las-notificaciones-remotas-en-la-app","title":"Gesti\u00f3n de las notificaciones remotas en la app","text":""},{"location":"teoria/notificaciones/notificaciones.html#capacidad-de-notificacion-remota","title":"Capacidad de notificaci\u00f3n remota","text":"<p>La app debe tener el permiso de usar las notificaciones remotas. Debe usar un perfil de aprovisionamiento con un App ID que otorgue ese permiso. </p> <p>Se puede hacer desde Xcode o desde el la web de desarrollador. En la demostraci\u00f3n lo haremos desde la web del programa de desarrollo de la universidad. </p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#registro-de-las-notificaciones","title":"Registro de las notificaciones","text":"<p>Para que una app trabaje con notificaciones remotas lo primero que debe hacerse, al igual que con las notificaciones locales, es pedir permiso al usuario. La forma de hacerlo es id\u00e9ntica a las de las notificaciones locales, usando el m\u00e9todo <code>requestAuthorization(options:completionHandler:)</code>. </p> <p>Una vez hecho esto, hay que conseguir el token asociado al dispositivo y la app registr\u00e1ndose en el Apple Push Notification service (APNs). Lo hace el m\u00e9todo <code>registerForRemoteNotifications</code> del objeto application. </p> <p>Se trata de un m\u00e9todo as\u00edncrono. Si el registro en el servicio tiene \u00e9xito, la app llama al m\u00e9todo <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code> del delegado de la aplicaci\u00f3n pasando el token asignado que habr\u00e1 que incluir en las notificaciones que enviemos al dispositivo.</p> <p>Ejemplo de c\u00f3digo de registro de las notificaciones remotas:</p> <pre><code>func application(_ application: UIApplication, \n                 didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {\n    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge])\n    { (granted, error) in print(granted)}\n    application.registerForRemoteNotifications()\n    UNUserNotificationCenter.current().delegate = self\n    return true\n}\n</code></pre> <p>Ejemplo de obtenci\u00f3n del token e impresi\u00f3n en la consola:</p> <pre><code>func application(_ application: UIApplication, \n                 didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n    var token = \"\"\n    for i in 0..&lt;deviceToken.count {\n        token = token + String(format: \"%02.2hhx\", arguments: [deviceToken[i]])\n    }\n    print(token)\n}\n\nfunc application(_ application: UIApplication, \n                 didFailToRegisterForRemoteNotificationsWithError error: Error) {\n    print(\"Failed to register:\", error)\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#recepcion-de-las-notificaciones-en-la-app","title":"Recepci\u00f3n de las notificaciones en la app","text":"<p>La gesti\u00f3n de las notificaciones recibidas es id\u00e9ntica a la ya vista en notificaciones locales, us\u00e1ndose exactamente los mismos manejadores, con la excepci\u00f3n de la posibilidad de gestionar notificaciones remotas cuando la app est\u00e1 en segundo plano.</p> <p>Recordemos los manejadores que ya vimos en las notificaciones locales:</p> <ul> <li>Si la app est\u00e1 en primer plano se llama al metodo   <code>userNotificationCenter(willPresent:withCompletionHandler:)</code> del   <code>UNUserNotificationCenterDelegate</code> cuando llega la notificaci\u00f3n.</li> <li>Si la app est\u00e1 en segundo plano y el usuario pulsa en la   notificaci\u00f3n o en una de sus acciones se llama a   <code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code> del   <code>UNUserNotificationCenterDelegate</code>. </li> </ul> <p>La diferencia de las notificaciones remotas es la posibilidad de definir el manejador <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> del delegado del app, que se activa cuando llega una notificaci\u00f3n remota que contiene la clave <code>content-available</code> con el valor <code>1</code>:</p> <pre><code>{\n   \"aps\" : {\n      \"content-available\" : 1\n   },\n   \"acme1\" : \"bar\",\n   \"acme2\" : 42\n}\n</code></pre> <p>Para que se llame al m\u00e9todo se debe activar la capability <code>Background Modes &gt; Remote Notifications</code> en Xcode.</p> <p></p> <p>El m\u00e9todo se llama tanto si la app est\u00e1 en primer plano como si est\u00e1 en segundo plano. De hecho, es recomendable usarlo \u00fanicamente para gestionar notificaciones silenciosas que no se muestran al usuario sino que se usan para que la app pueda recuperar informaci\u00f3n del servidor que se mostrar\u00e1 la siguiente vez que el usuario lance la app.</p> <p>Por ello habr\u00eda que enviar un payload como el que hemos visto anteriormente. Con custom keys pero en el que el diccionario <code>aps</code> no contenga ninguna clave que disparare una interacci\u00f3n con el usuario.</p>"},{"location":"teoria/notificaciones/notificaciones.html#ejemplo-de-app","title":"Ejemplo de app","text":"<p>Ejemplo de app que usaremos para demostrar las notificaciones remotas:</p> <p></p> <p>C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando la app est\u00e1 en primer plano:</p> <pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, \n                         willPresent notification: UNNotification, \n                         withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) {\n    print(\"Recibida notificaci\u00f3n primer plano\")\n    let userInfo = notification.request.content.userInfo\n    createNewNewsItem(text: message(userInfo: userInfo) +\n                      \" (userNotificationCenter willPresent)\")\n    // No mostramos la notificaci\u00f3n\n    completionHandler([])\n}\n</code></pre> <p>C\u00f3digo de gesti\u00f3n de la notificaci\u00f3n cuando ha sido accionada por el usuario:</p> <pre><code>func userNotificationCenter(_ center: UNUserNotificationCenter, \n                        didReceive response: UNNotificationResponse, \n                        withCompletionHandler completionHandler: @escaping () -&gt; Void) {\n    print(\"Usuario ha pulsado una notificaci\u00f3n\")\n    let userInfo = response.notification.request.content.userInfo\n    createNewNewsItem(text: message(userInfo: userInfo) + \" (userNotificationCenter didReceive)\")\n    completionHandler()\n}\n</code></pre> <p>C\u00f3digo de gesti\u00f3n de una notificaci\u00f3n silenciosa:</p> <pre><code>func application(_ application: UIApplication, \n                 didReceiveRemoteNotification userInfo: [AnyHashable : Any], \n                 fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) {\n    print(\"Recibida notificaci\u00f3n remota en background\")\n    createNewNewsItem(text: message(userInfo: userInfo) +\n                      \" (UIApplication didReceiveRemoteNotification)\")\n    completionHandler(UIBackgroundFetchResult.newData)\n}\n</code></pre> <p>La funci\u00f3n <code>message(userInfo:)</code> devuelve un <code>String</code> con el mensaje contenido en la notificaci\u00f3n:</p> <pre><code>func message(userInfo: [AnyHashable : Any]) -&gt; String {\n    // Buscamos el mensaje en las claves custom\n    if let message = userInfo[\"mensaje\"] as? String {\n        return message\n    } else {\n        // Cogemos como mensaje el valor o el t\u00edtulo de la alerta\n        let aps = userInfo[\"aps\"] as! [String: AnyObject]\n        if let message = aps[\"alert\"] as? String {\n            return message\n        } else if let dic = aps[\"alert\"] as? [String: AnyObject] {\n            return dic[\"title\"] as! String\n        } else {\n            return \"\"\n        }\n    }\n}\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#ejercicio","title":"Ejercicio","text":""},{"location":"teoria/notificaciones/notificaciones.html#pasos-necesarios-para-el-ejercicio","title":"Pasos necesarios para el ejercicio","text":"<p>En la demo vamos a mostrar c\u00f3mo se env\u00edan y reciben notificaciones remotas. Ejecutaremos una app que va a recibir las notificaciones (NotificacionesPush) en un dispositivo real.</p> <p>Podremos enviar notificaciones a este dispositivo real utilizando un script que tendremos que configurar con:</p> <ul> <li>JWT codificado que contiene el Team Id y el Key ID proporcionado   por Apple. Para la codificaci\u00f3n necesitaremos una clave de   autenticaci\u00f3n tambi\u00e9n proporcionada por Apple con un fichero de   texto con la extensi\u00f3n <code>.p8</code>.</li> <li>Bundle ID incluido en un AppID con el permiso de notificaciones   push.</li> <li>Token del dispositivo.</li> </ul>"},{"location":"teoria/notificaciones/notificaciones.html#nuevo-app-id-en-el-member-center-admin","title":"Nuevo App ID en el member center (admin)","text":"<p>Un administrador del equipo UA debe crear una App ID con el nombre expl\u00edcito de la app que se va a poner en producci\u00f3n y con la autorizaci\u00f3n para las notificaciones push.</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#creacion-de-la-clave-de-encriptacion-y-la-key-id-de-apple-admin","title":"Creaci\u00f3n de la clave de encriptaci\u00f3n y la Key ID de Apple (admin)","text":"<p>Para poder encriptar el token JWT y poder usarlo para enviar la notificaci\u00f3n es necesario crear en el portal de desarrollo de Apple una clave de encriptaci\u00f3n para acceder al Servicio de Notificaciones Push de Apple (APNs). Estos pasos solo los puede realizar un administrador del equipo de la universidad.</p> <p>Primero se pulsa en la opci\u00f3n de a\u00f1adir una nueva clave:</p> <p></p> <p>Y despu\u00e9s se crea la clave, proporcionando un nombre de identificaci\u00f3n (en nuestro caso <code>Notificaciones Push Master Moviles</code>):</p> <p></p> <p>Y por \u00faltimo confirmamos la nueva clave pulsando el bot\u00f3n <code>Register</code>:</p> <p></p> <p>Una vez confirmada la clave, podemos descargarnos el fichero con la clave privada (solo una vez) y se crea un identificador de clave (Key ID) que se guarda en el portal del desarrollador y podremos consultar cuando sea necesario.</p> <p></p> <p>El fichero que se descarga es un fichero de texto con la extensi\u00f3n <code>.p8</code> que contiene la clave privada con la que podremos encriptar el token JWT. Lo debes guardar en un lugar seguro, porque solo puedes descargarlo una vez.</p> <p>Una vez creada la clave, podr\u00e1s consultar su informaci\u00f3n en el apartado <code>Keys</code> del portal de desarrollador:</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#probamos-la-app-notificacionespush-y-obtenemos-el-token-del-dispositivo","title":"Probamos la app <code>NotificacionesPush</code> y obtenemos el token del dispositivo","text":"<p>Necesitamos obtener el token del dispositivo y de la app que va a recibir la notificaci\u00f3n. Para ello debemos ejecutar la app en un dispositivo f\u00edsico (no funciona en el simulador).</p> <p>Descargamos el proyecto NotificacionesPush desde este enlace. Contiene la app y los scripts para enviar las notificaciones al APNs. </p> <p>La app debe estar firmada con el perfil de aprovisionamiento creado y deben estar configuradas las capabilities para activar las notificaciones push:</p> <p></p> <p>Ejecutamos el app en un dispositivo f\u00edsico en el que recibiremos las notificaciones remotas, ya que \u00e9stas no funcionan en el simulador.</p> <p>Anotamos el token del dispositivo que aparece en la consola al ejecutar la app por primera vez.</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#probamos-a-enviar-notificaciones-remotas-al-dispositivo","title":"Probamos a enviar notificaciones remotas al dispositivo","text":"<p>En el directorio <code>Scripts</code> del fichero descargado se encuentra el fichero <code>.p8</code> con la clave privada y los scripts <code>encode_jwt.sh</code> y <code>send_push_notification.sh</code>.</p> <ol> <li> <p>Nos aseguramos de que el script <code>encode_jwt.sh</code> incluye:</p> <ul> <li>el Team ID del equipo de la UA, disponible en el portal del desarrollador </li> <li>el Key ID, disponible tambi\u00e9n en el portal del desarrollador   (lo puede consultar el profesor, administrador del equipo de la UA)</li> <li>el nombre del fichero <code>.p8</code> incluido en el directorio</li> </ul> </li> <li> <p>Ejecutamos el comando <code>encode_jwt.sh</code> y obtenemos el JWT    codificado:</p> </li> </ol> <pre><code>% ./encode_jwt.sh\neyAiYWxnIjogIkVTMjUwIhwgImtpZCI6ICJXM0g2WjlBNFI0IiB9.\neyAiaXNzIjogIjNTOTUyQUdINDYiLCAiaWF0IjogMTY0ODA1ODc2N\nSB9.MEACIAvaPw6dP6d7ljQatmO5HsxK0J9NDVpd_xFBc-N4acLAAiAL\nEo7pNb1k4_awSDicbjsz7dC1LkiGRgMgYXbh8Os13z\n</code></pre> <ol> <li> <p>Este JWT tiene una duraci\u00f3n de 1 hora. Si pasa ese tiempo deberemos    volver a ejecutar el comando para generar otro.</p> </li> <li> <p>Copiamos el JWT y lo incluimos en el fichero    <code>send_push_notification.sh</code>. Tambi\u00e9n debemos incluir el bundle ID    del AppID (<code>es.ua.mudsdm.NotificacionesPush</code>) y el token del dispositivo.</p> </li> <li> <p>La notificaci\u00f3n que se env\u00eda es una notificaci\u00f3n con una    alerta. Podemos cambiar el payload de la notificaci\u00f3n para probar    distintas configuraciones.</p> </li> <li> <p>Llamamos al script para lanzar una notificaci\u00f3n remota al dispositivo:</p> </li> </ol> <pre><code>% ./send_push_notification.sh \n\n*   Trying 17.188.168.147:443...\n* Connected to api.sandbox.push.apple.com (17.188.168.147) port 443 (#0)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n*  CAfile: /etc/ssl/cert.pem\n*  CApath: none\n* (304) (OUT), TLS handshake, Client hello (1):\n* (304) (IN), TLS handshake, Server hello (2):\n* (304) (IN), TLS handshake, Unknown (8):\n* (304) (IN), TLS handshake, Request CERT (13):\n* (304) (IN), TLS handshake, Certificate (11):\n* (304) (IN), TLS handshake, CERT verify (15):\n* (304) (IN), TLS handshake, Finished (20):\n* (304) (OUT), TLS handshake, Certificate (11):\n* (304) (OUT), TLS handshake, Finished (20):\n* SSL connection using TLSv1.3 / AEAD-CHACHA20-POLY1305-SHA256\n* ALPN, server accepted to use h2\n* Server certificate:\n*  subject: CN=api.development.push.apple.com; OU=management:idms.group.533599; O=Apple Inc.; ST=California; C=US\n*  start date: Dec 10 00:29:46 2021 GMT\n*  expire date: Jan  9 00:29:45 2023 GMT\n*  subjectAltName: host \"api.sandbox.push.apple.com\" matched cert's \"api.sandbox.push.apple.com\"\n*  issuer: CN=Apple Public Server RSA CA 12 - G1; O=Apple Inc.; ST=California; C=US\n*  SSL certificate verify ok.\n* Using HTTP2, server supports multiplexing\n* Connection state changed (HTTP/2 confirmed)\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* Using Stream ID: 1 (easy handle 0x15700e600)\n&gt; POST /3/device/a7aece1640f3e3b787f3f88c33523eb1231fcd27ebe3c22170c472b02447af38 HTTP/2\n&gt; Host: api.sandbox.push.apple.com\n&gt; user-agent: curl/7.79.1\n&gt; accept: */*\n&gt; authorization: bearer eyAiYWxnIjogIkVTMjU2IiwgImtpZCI6ICJXM0g2WjlBNFI0IiB9.eyAiaXNzIjogIjNTOTUyQUdINDYiLCAiaWF0IjogMTY0ODA1ODc2NSB9.MEQCIAvaPw6dP6d7ljQatmO5HsxK0J9NDVpd_xFBc-N4acLAAiALEo7pNb1k4_awSDicbjsz7dC1LkiGRgMgYXbh8Of13w\n&gt; apns-topic: es.ua.mudsdm.NotificacionesPush\n&gt; content-length: 198\n&gt; content-type: application/x-www-form-urlencoded\n&gt; \n* We are completely uploaded and fine\n* Connection state changed (MAX_CONCURRENT_STREAMS == 1)!\n* Connection state changed (MAX_CONCURRENT_STREAMS == 1000)!\n&lt; HTTP/2 200 \n&lt; apns-id: 07C0F2E2-7CE0-71EC-D0D6-E7089220F778\n&lt; \n* Connection #0 to host api.sandbox.push.apple.com left intact\n</code></pre> <p>Y la notificaci\u00f3n debe llegar correctamente al dispositivo:</p> <p></p>"},{"location":"teoria/notificaciones/notificaciones.html#notificacion-silenciosa","title":"Notificaci\u00f3n silenciosa","text":"<p>Para enviar una notificaci\u00f3n silenciosa (no se muestra al usuario, pero llega a la app) hay que a\u00f1adir la cabecera <code>apns-push-type: background</code> y construir un payload que tenga el atributo <code>content-available</code> a 1. En el script est\u00e1n comentadas las dos l\u00edneas que habr\u00eda que a\u00f1adir:</p> <pre><code>curl -v \\\n--http2 \\\n--header \"authorization: bearer $JWT\" \\\n--header \"apns-topic: ${BUNDLEID}\" \\\n--header \"apns-push-type: background\" \\\n--data '{\"aps\" : {\"content-available\" : 1}, \"mensaje\" : \"Holaaaa\"}' \\\n\"${URL}\"\n</code></pre>"},{"location":"teoria/notificaciones/notificaciones.html#bibliografia","title":"Bibliograf\u00eda","text":"<ul> <li>Framework UserNotifications</li> <li>Asking Permission to Use Notifications</li> <li>Scheduling a Notification Locally from Your App</li> <li>Handling Notifications and Notification-Related Actions</li> <li>Registering Your App with APNs</li> <li>Generating a Remote   Notification</li> <li>Pushing Updates to Your App Silently</li> <li>Setting Up a Remote Notification Server</li> <li>Establishing a Certificate-Based Connection to APNs</li> <li>Establishing a Token-Based Connection to APNs</li> </ul>"},{"location":"teoria/swiftui/swiftui.html","title":"SwiftUI","text":"<p>La arquitectura de una aplicaci\u00f3n basada en SwiftUI presenta diferencias significativas respecto a una basada en Storyboards. Esto nos obliga a reorganizar los componentes utilizados para la gesti\u00f3n del modelo y de los servicios a los que accede nuestra aplicaci\u00f3n. En esta sesi\u00f3n extra nos centraremos en estudiar los mecanismos que nos ofrece SwiftUI para gestionar estos objetos.</p>"},{"location":"teoria/swiftui/swiftui.html#objetos-observables","title":"Objetos observables","text":"<p>En la sesi\u00f3n introductoria sobre SwiftUI se trataron las variable <code>@State</code>. Vimos c\u00f3mo los cambios en estas variables se reflejan autom\u00e1ticamente en la interfaz. Esto es as\u00ed con tipos de datos b\u00e1sicos, pero si queremos tener este mismo comportamiento con nuestros propios objetos deberemos marcarlos con el property wrapper <code>@Observable</code>.</p> <p>Por ejemplo, en una aplicaci\u00f3n de gesti\u00f3n de tareas definimos una estructura <code>ToDoItem</code> para representar los datos de cada tarea, y una clase <code>ToDoModel</code> para gestionar el modelo:</p> <pre><code>struct ToDoItem : Identifiable {\n    var id = UUID()\n    var nombreItem: String\n    var completado: Bool = false\n    var fechaFinalizacion: Date? = nil   \n}\n\n@Observable\nclass ToDoModel: NSObject {\n\n    var toDoItems: [ToDoItem] = []\n\n    override init() {\n        super.init()        \n    }\n\n    func addItem(item: ToDoItem) {\n        toDoItems.append(item)\n    }\n}\n</code></pre> <p>Destacamos que la clase <code>ToDoModel</code> est\u00e1 marcada como <code>@Obserbable</code>. De esta forma, en nuestra aplicaci\u00f3n podr\u00edamos crear el modelo como una variable <code>@State</code>, y los cambios que se produzcan en la lista de tareas (creaci\u00f3n, modificaci\u00f3n o borrado de tareas) se reflejar\u00e1n de forma autom\u00e1tica en la interfaz.</p> <p>La clase del modelo es un lugar apropiado para introducir el c\u00f3digo de acceso a iCloud y CloudKit. Por ejemplo, desde <code>init</code> podemos recuperar todos los registros de la base de datos de CloudKit, y en <code>addItem</code> adem\u00e1s de a\u00f1adir el item en la lista local, podemos a\u00f1adir el nuevo registro en CloudKit. Podemos tambi\u00e9n utilizar esta clase para gestionar el contador de tareas finalizadas, y almacenar y recuperar su valor del almacen de parejas clave-valor de iCloud. </p> <p>Tambi\u00e9n cabe destacar el haber declarado la estructura <code>ToDoItem</code> como <code>Identifiable</code>. Este protocolo nos obliga a declarar una propiedad <code>id</code> que debe ser \u00fanica. El cumplir con dicho protocolo nos permitir\u00e1 iterar por elementos de dicho tipo utilizando <code>ForEach</code> sin tener que indicar un identificador de forma expl\u00edfica, como se muestra a continuaci\u00f3n al crear la lista:</p> <pre><code>struct ToDoList: View {\n    @State private var model = ToDoModel()\n\n    var body: some View {        \n        NavigationView {\n            List() {\n                ForEach(model.toDoItems) { item in\n                    ToDoRow(item: item)\n                }\n            }\n        }\n    }\n}\n\nstruct ToDoRow: View {\n    var item: ToDoItem\n\n    var body: some View {\n        HStack {\n            Text(item.nombreItem)\n            Spacer()\n            if item.completado {\n                Image(systemName: \"checkmark\")\n            }\n        }\n    }\n}\n</code></pre> <p>Para la creaci\u00f3n de la imagen se utiliza un nombre del sistema, que nos da acceso a una amplia galer\u00eda de iconos. Se puede explorar esta galer\u00eda descargando la aplicaci\u00f3n SF Symbols.</p>"},{"location":"teoria/swiftui/swiftui.html#objetos-del-entorno","title":"Objetos del entorno","text":"<p>En el punto anterior hemos visto c\u00f3mo crear la clase para gestionar el modelo de nuestra aplicaci\u00f3n y c\u00f3mo hacerla <code>@Observable</code> e incluirla como variable <code>@State</code> de nuestra clase. Este tipo de variables se deben declarar como privadas de la vista en la que se crean, sin embargo, el modelo es un objeto al que necesitaremos tener acceso desde un gran n\u00famero de vistas. </p> <p>En estos casos es conveniente introducir este objeto en el entorno de la aplicaci\u00f3n, de forma que podamos acceder a \u00e9l desde cualquier subvista. Para ello, instanciaremos el modelo en la vista ra\u00edz como variable <code>@State</code>, y al crear la vista <code>ToDoList</code> lo introduciremos en el entorno con <code>environment</code>:</p> <pre><code>struct ToDoSwiftUIApp: App {\n    @State private var model = ToDoModel()\n\n    var body: some Scene {\n        WindowGroup {\n            ToDoList()\n                .environment(model)\n        }\n    }\n}\n</code></pre> <p>S\u00f3lo los objetos marcados como <code>@Observable</code> pueden ser introducidos en el entorno.</p> <p>De esta forma, tanto <code>ToDoList</code> como todas sus vistas descendientes tendr\u00e1n acceso al modelo inyect\u00e1ndolo con <code>@Environment</code>, como se muestra a continuaci\u00f3n:</p> <pre><code>struct ToDoList: View {\n    @Environment(ToDoModel.self) private var model\n\n    var body: some View {        \n        NavigationView {\n            List() {\n                ForEach(model.toDoItems) { item in\n                    ToDoRow(item: item)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Es importante resaltar que una variable se declara como <code>@State</code> solo cuando estamos en la vista que la crea (en este caso es en la clase principal de la aplicaci\u00f3n <code>ToDoSwiftUIApp</code>), y siempre se debe definir como privada. </p> <p>Los property wrappers <code>@Observable</code> y <code>@Environment</code> se introducen en iOS 17. Si querermos soportar versiones anteriores de la plataforma deberemos utilizar <code>@ObservedObject</code> (el objeto declarado de esta forma deber\u00e1 adoptar el protocolo <code>ObservableObject</code>), <code>@StateObject</code> y <code>@EnvironmentObject</code> en su lugar. Su uso es similar, pero deberemos marcar las propiedades que queramos observar una a una como <code>@Published</code>. En la bibliograf\u00eda se incluye una comparativa de las diferencias entre las dos versiones (Migrating from the Observable Object protocol to the Observable macro).</p>"},{"location":"teoria/swiftui/swiftui.html#binding-con-propiedades-del-modelo","title":"Binding con propiedades del modelo","text":"<p>Ser\u00e1 habitual necesitar modificar propiedades del modelo en alguna vista. Por ejemplo, en nuestro caso nos puede interesar modificar la propiedad <code>completado</code> de las tareas de la lista. Para ello, deberemos hacer las propiedades de dicho objeto <code>@Bindables</code>.</p> <p>Si nuestro objeto ha sido recuperado como objeto del entorno, podemos hacerlo <code>@Bindable</code> de la siguiente forma:</p> <pre><code>struct ToDoList: View {    \n    @Environment(ToDoModel.self) private var model\n\n    var body: some View {\n        @Bindable var model = model\n\n        NavigationView {\n            List() {\n                ForEach($model.toDoItems) { $item in\n                    ToDoRow(item: item)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            item.completado.toggle()\n                            item.fechaFinalizacion = Date()\n                        }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Podemos observar que re-declaramos el modelo dentro de nuestra vista para hacerlo <code>@Bindable</code>. De esta forma, podemos utilizar binding para que al obtener cada item de la lista (observar el uso de <code>$</code> dentro del <code>ForEach</code>), este quede vinculado con su estructura dentro del modelo y de esta forma los cambios en la interfaz se reflejen en los datos del modelo.</p> <p>Destacamos tambi\u00e9n en este c\u00f3digo el uso de <code>contentShape</code>. Al utilizar <code>onTapGesture</code>, por defecto solo registrar\u00e1 el evento cuando pulsemos sobre un lugar de la fila que tenga contenido (texto o s\u00edmbolo de check). Haciendo que <code>contentShape</code> sea rectangular, conseguimos que todo el rect\u00e1ngulo que ocupa la fila sea sensible a los eventos tap.</p>"},{"location":"teoria/swiftui/swiftui.html#valores-del-entorno-proporcionados-por-el-sistema","title":"Valores del entorno proporcionados por el sistema","text":"<p>Hemos visto c\u00f3mo incluir nuestros objetos en el entorno de la aplicaci\u00f3n. Adem\u00e1s, podemos encontrar en el entorno diferentes valores que nos proporciona el sistema, y que nos pueden ser de gran utilidad para nuestra aplicaci\u00f3n. </p> <p>Por ejemplo, si inyectamos el valor <code>\\.scenePhase</code> tendremos informaci\u00f3n sobre el estado en el que se encuentra la aplicaci\u00f3n (activa, inactiva o en background). Podemos utilizar <code>onChange</code> para observar cu\u00e1ndo cambia esta propiedad, como se muestra a continuaci\u00f3n:</p> <pre><code>struct ToDoList: View {\n\n    @Environment(ToDoModel.self) private var model\n    @Environment(\\.scenePhase) var scenePhase\n\n    var body: some View {\n        @Bindable var model = model\n\n        NavigationView {\n            List() {\n                ForEach($model.toDoItems) { $item in\n                    ToDoRow(item: item)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            item.completado.toggle()\n                            item.fechaFinalizacion = Date()\n                        }\n                }\n            }\n            .onChange(of: scenePhase) {\n                if(scenePhase == .active) {\n                    print(\"Aplicacion activa\")\n                } else if(scenePhase == .background) {\n                    print(\"La aplicacion ha ido a background\")\n                } \n            }\n        }\n    }\n}\n</code></pre> <p>Resulta de gran utilidad tambi\u00e9n la propiedad <code>dismiss</code>, que nos permitir\u00e1 cerrar cualquier vista modal. Por ejemplo, podemos utilizar <code>sheet</code> para abrir una vista modal para a\u00f1adir una nueva tarea:</p> <pre><code>struct ToDoList: View {    \n    @Environment(ToDoModel.self) private var model\n    @State private var isAddItemPresented : Bool = false\n\n    var body: some View {\n        @Bindable var model = model\n\n        NavigationView {\n            List() {\n                ForEach($model.toDoItems) { $item in\n                    ToDoRow(item: item)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            item.completado.toggle()\n                            item.fechaFinalizacion = Date()\n                        }\n                }\n            }\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Add Item\", systemImage: \"plus\") {\n                        self.isAddItemPresented = true\n                    }\n                }\n            }\n            .sheet(isPresented: $isAddItemPresented) {\n                AddTask()\n            }\n\n        }\n    }\n}\n</code></pre> <p>Podemos ver que para controlar si la vista modal se muestra o no utilizamos una variable <code>@State</code> <code>isAddItemPresented</code>. A\u00f1adimos un bot\u00f3n a la barra de herramientas (<code>ToolbarItem</code>) que al pulsarse pone dicha propiedad a <code>true</code> y de esa forma muestra la vista modal. </p> <p>Podemos cerrar la vista modal simplemente poniendo la propiedad de nuevo a <code>false</code>, dentro desde dentro del c\u00f3digo de la vista nos puede ser m\u00e1s sencillo simplemente utilizar <code>dismiss</code>, como se muestra a continuaci\u00f3n:</p> <pre><code>struct AddTask: View {\n    @Environment(\\.dismiss) var dismiss\n    @Environment(ToDoModel.self) private var model\n    @State private var item: ToDoItem = ToDoItem(nombreItem: \"\")\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                List {\n                    TextField(\"Descripci\u00f3n de la tarea\", text: $item.nombreItem)\n                    Toggle(\"Completado\", isOn: $item.completado)\n                }\n            }.toolbar() {\n                ToolbarItem(placement: .confirmationAction) {\n                    Button(\"Save\") {\n                        if(!item.nombreItem.isEmpty) {\n                            model.addItem(item: item)\n                        }\n                        dismiss()\n                    }\n                }\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>En la clase anterior definimos la nueva tarea como variable <code>@State</code>, y una toolbar con las opciones Save y Cancel. Vemos adem\u00e1s que inyectamos el modelo, de forma que en caso de seleccionar Save a\u00f1adimos el nuevo item a la lista. Tanto si seleccionamos Cancel como Save, llamaremos a <code>dismiss()</code> para cerrar la vista modal.</p> <p>Podemos ver todos los valores del entorno disponibles en la documentaci\u00f3n de la clase EnvironmentValues.</p>"},{"location":"teoria/swiftui/swiftui.html#binding-en-nuestras-propias-vistas","title":"Binding en nuestras propias vistas","text":"<p>Hemos visto c\u00f3mo utilizar binding para que diferentes vistas de SwiftUI sean capaces de modificar nuestros datos. Puede que queramos crear una vista propia que sea capaz de hacer lo mismo, y recibir un dato mediante binding que podamos editar. </p> <p>A continuaci\u00f3n, vemos un ejemplo de vista que nos muestra los datos de una tarea y un bot\u00f3n que nos permite ir a una pantalla para editarla. Dado que se trata de una pantalla de edici\u00f3n que deber\u00e1 poder modificar nuestra tarea, el item se debe pasar mediante binding (<code>$item</code>):</p> <pre><code>struct ViewTask: View {\n    @State private var item: ToDoItem = ToDoItem(nombreItem: \"\")\n    @State private var isEditItemPresented = false\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                List {\n                    Text(item.nombreItem)\n                    Text(item.completado ? \"Completado\" : \"Pendiente\")\n                }\n                Button(\"Editar\") {\n                    isEditItemPresented = true\n                }\n            }.sheet(isPresented: $isEditItemPresented) {\n                // Creamos vista modal para a\u00f1adir una nueva tarea\n                EditTask(item: $item)\n            }\n        }\n    }\n}\n</code></pre> <p>Para que esto sea posible en la pantalla de edici\u00f3n definimos la variable <code>item</code> como <code>@Binding</code>. De esta forma podr\u00e1 recibir el dato vinculado y podr\u00e1 modificar su contenido:</p> <pre><code>struct EditTask: View {\n    @Environment(\\.dismiss) var dismiss\n    @Binding var item: ToDoItem\n\n    var body: some View {\n        NavigationView {\n            List {\n                TextField(\"Descripci\u00f3n de la tarea\", text: $item.nombreItem)\n                Toggle(\"Completado\", isOn: $item.completado)\n            }.toolbar() {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cerrar\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>En la sesi\u00f3n introductoria sobre SwiftUI se trataron las variable <code>@State</code> y el binding. Declaramos una variable como <code>@State</code> en el lugar donde se crea el objeto, y debemos marcarla como privada ya que nunca deber\u00eda utilizarse fuera de ese \u00e1mbito.</p> <p>Sin embargo, existen mecanismos para pasar ese objeto a otras vistas, que se encuentren por debajo en la jerarqu\u00eda de vistas. Una de las formas es simplemente pasar dicho objeto como par\u00e1metro a otra vista. </p> <p>Esto es lo que hemos visto anteriormente  Por ejemplo, a continuaci\u00f3n se muestra el c\u00f3digo de una vista para ver los datos de una tarea (su nombre y si es p\u00fablica o no). Dicha clase crea la tarea (<code>ToDoItem</code>) y la declara como <code>@State private</code></p>"},{"location":"teoria/swiftui/swiftui.html#inclusion-del-appdelegate","title":"Inclusi\u00f3n del AppDelegate","text":"<p>Hemos visto que la clase <code>AppDelegate</code> nos proporciona determinados callbacks, como por ejemplo <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> para recibir notificaciones remotas. </p> <p>En una aplicaci\u00f3n SwiftUI el punto de entrada no es una clase <code>AppDelegate</code>, sino una vista que hereda de <code>App</code>. Podemos, no obstante, a\u00f1adir una clase <code>AppDelegate</code> a nuestra aplicaci\u00f3n SwiftUI. Para ello, crearemos en primer lugar dicha clase, que adopte el protocolo <code>UIApplicationDelegate</code> y definiremos los m\u00e9todos que necesitemos de dicha clase: </p> <pre><code>class AppDelegate: NSObject, UIApplicationDelegate {\n    // MARK: - Delegates\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions\n                     launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -&gt; Bool {\n        return true\n    }\n\n}\n</code></pre> <p>A continuaci\u00f3n, desde nuestra vista <code>App</code> de SwiftUI inyectamos dicha clase <code>AppDelegate</code> mediante <code>@UIApplicationDelegateAdaptor</code>:</p> <pre><code>struct ToDoSwiftUIApp: App {\n    @State private var model = ToDoModel()\n    @UIApplicationDelegateAdaptor(AppDelegate.self) var delegate\n\n    var body: some Scene {\n        WindowGroup {\n            ToDoList()\n                .environment(model)\n        }\n    }\n}\n</code></pre> <p>Con esto podremos contar con los m\u00e9todos de dicha clase de la misma forma que en una aplicaci\u00f3n basada en storyboards. </p>"},{"location":"teoria/swiftui/swiftui.html#bibliografia","title":"Bibliograf\u00eda","text":"<ul> <li>Managing model data in your app</li> <li>Monitoring data changes in your app</li> <li>Migrating from the Observable Object protocol to the Observable macro</li> <li>Managing user interface state</li> <li>UIApplicationDelegateAdaptor</li> </ul>"}]}